# Initially generated by GitHub Copilot.
"""
Replace unnecessary \\uXXXX escape sequences with literal UTF-8 characters.

Companion to check_escape_sequences.py.  Uses the same _KEEP_AS_ESCAPE set
and raw-string / docstring-regex detection logic so that only escapes flagged
by the checker are replaced.

Usage:
    python fix_escape_sequences.py          # dry-run (default)
    python fix_escape_sequences.py --apply  # write changes

Exit codes:
    0 – No changes needed (or all changes applied)
    1 – Changes needed but --apply not given
"""

import sys
from pathlib import Path

# Import the checker’s definitions so the two scripts stay in sync.
from check_escape_sequences import (
    ESCAPE_RE,
    _check_file,
    _tracked_files,
    _should_be_literal,
    _raw_string_spans,
    _in_raw_string,
    _is_docstring_regex_example,
)


def _fix_line(line):
    """Return (new_line, n_fixes) with unnecessary escapes replaced."""
    if _is_docstring_regex_example(line):
        return line, 0

    raw_spans = _raw_string_spans(line)
    parts = []
    last_end = 0
    n_fixes = 0

    for m in ESCAPE_RE.finditer(line):
        cp = int(m.group(1), 16)
        if _should_be_literal(cp) and not _in_raw_string(m.start(), raw_spans):
            parts.append(line[last_end : m.start()])
            parts.append(chr(cp))
            n_fixes += 1
        else:
            parts.append(line[last_end : m.end()])
        last_end = m.end()

    parts.append(line[last_end:])
    return "".join(parts), n_fixes


def _fix_file(path):
    """Fix all unnecessary escapes in *path*.  Return (new_text, n_fixes)."""
    text = path.read_text(encoding="utf-8")
    new_lines = []
    total_fixes = 0
    for line in text.splitlines(keepends=True):
        new_line, n = _fix_line(line)
        new_lines.append(new_line)
        total_fixes += n
    return "".join(new_lines), total_fixes


def main():
    apply = "--apply" in sys.argv
    root = Path(__file__).resolve().parent
    files = list(_tracked_files(root))
    total_fixes = 0

    for path in files:
        violations = _check_file(path, root)
        if not violations:
            continue
        new_text, n = _fix_file(path)
        rel = path.relative_to(root)
        if apply:
            path.write_text(new_text, encoding="utf-8")
            print(f"  FIXED {rel}: {n} replacement(s)")
        else:
            print(f"  WOULD FIX {rel}: {n} replacement(s)")
        total_fixes += n

    if total_fixes == 0:
        print("Nothing to fix.")
        return 0
    if apply:
        print(f"\nApplied {total_fixes} fix(es).")
        return 0
    print(f"\nDry-run: {total_fixes} fix(es) needed.  Re-run with --apply.")
    return 1


if __name__ == "__main__":
    sys.exit(main())
