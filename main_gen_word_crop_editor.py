# Initially generated by GitHub Copilot.
"""
Interactive word-crop editor for Aleppo Codex quirkrec images.

Generates an HTML page (.novc/word_crop_editor.html) where each quirkrec
shows its page-crop image with a draggable bounding box initialized from
the Hebrew-metrics word-position estimate.  Adjust boxes with mouse handles
or arrow keys, then Export JSON to clipboard for downstream processing.

Usage:
    python main_gen_word_crop_editor.py           # example quirkrecs only
    python main_gen_word_crop_editor.py --all      # all missing aleppo images
"""

import json
import os
import sys
import traceback
import webbrowser
from pathlib import Path

import numpy as np
from PIL import Image

ROOT = Path(__file__).resolve().parent
OUT_DIR = ROOT / ".novc"

sys.path.insert(0, str(ROOT))
from py_ac_word_image_helper.codex_page import (
    CC_DIR,
    download_page,
    find_page_for_verse,
    get_line_bbox,
    load_index,
)
from py_ac_word_image_helper.hebrew_metrics import (
    SPACE_WIDTH,
    join_maqaf,
    line_widths,
)
from py_ac_word_image_helper.linebreak_search import find_word_in_linebreaks
from pyauthor_util.short_id_etc import short_id

with open(ROOT / "out" / "enriched-quirkrecs.json", encoding="utf-8") as _f:
    EQRS = json.load(_f)


# ── Process a single quirkrec ──────────────────────────────────────────


def process_quirkrec(qr, pages, scale=2):
    """Generate a crop image and return metadata with initial bbox."""
    sid = short_id(qr)
    cv = qr["qr-cv"]
    consensus = qr["qr-consensus"]
    ch, v = (int(x) for x in cv.split(":"))

    print(f"\n=== {sid} (Job {cv}): {consensus} ===")

    page_id = find_page_for_verse(pages, ch, v)
    if not page_id:
        print(f"  ERROR: Could not find page for Job {cv}")
        return None

    col, line_num, word_idx, line_words = find_word_in_linebreaks(
        page_id, ch, v, consensus
    )
    if col is None:
        print("  ERROR: Could not find word in line-break data")
        return None
    assert line_num is not None and word_idx is not None
    print(f"  Location: col {col}, line {line_num}, word {word_idx}")

    # Crop coordinates at reference image size
    crop_left, crop_top, crop_right, crop_bot, target_offset, ls = get_line_bbox(
        page_id, col, line_num
    )

    # Download page
    img = download_page(page_id, scale=scale)
    actual_w, actual_h = img.size

    # Scale factor: reference ↔ actual
    cc_path = CC_DIR / f"{page_id}.json"
    with open(cc_path, encoding="utf-8") as f:
        cc = json.load(f)
    ref_w = cc["image_size"]["width"]
    ref_h = cc["image_size"]["height"]
    sx = actual_w / ref_w
    sy = actual_h / ref_h

    # Scale crop coordinates to actual pixels
    cl = int(crop_left * sx)
    ct = int(crop_top * sy)
    cr = int(crop_right * sx)
    cb = int(crop_bot * sy)
    tgt_y = int(target_offset * sy)
    tgt_ls = int(ls * sy)

    crop = img.crop((cl, ct, cr, cb)).convert("RGBA")
    crop_w, crop_h = crop.size

    # Target line band
    highlight_top = tgt_y
    highlight_bot = tgt_y + tgt_ls

    # Horizontal word-position estimate (RTL)
    word_ws, total_width = line_widths(line_words)
    if total_width > 0:
        width_before = sum(word_ws[:word_idx]) + SPACE_WIDTH * word_idx
        width_target = word_ws[word_idx] if word_idx < len(word_ws) else 0
        frac_start = width_before / total_width
        frac_end = (width_before + width_target) / total_width
        buffer = 0.15
        frac_left = max(0, frac_start - buffer)
        frac_right = min(1, frac_end + buffer)
        highlight_right = int(crop_w * (1 - frac_left))
        highlight_left = int(crop_w * (1 - frac_right))
    else:
        highlight_left = 0
        highlight_right = crop_w

    # Initial bounding box (red-line region)
    half_ls = tgt_ls // 2
    box_top = max(0, highlight_top - half_ls)
    box_bot = min(crop_h - 1, highlight_bot + half_ls)

    # ── Fade overlay (visual guide) ────────
    h, w = crop_h, crop_w
    fade_color = (200, 180, 60)
    max_alpha = 200

    vert_fade = np.zeros(h, dtype=np.float64)
    for y in range(h):
        if y < highlight_top:
            dist = highlight_top - y
            fade_range = max(highlight_top, 1)
            vert_fade[y] = (dist / fade_range) ** 0.6
        elif y > highlight_bot:
            dist = y - highlight_bot
            fade_range = max(h - highlight_bot, 1)
            vert_fade[y] = (dist / fade_range) ** 0.6

    horiz_fade = np.zeros(w, dtype=np.float64)
    for x in range(w):
        if x < highlight_left:
            dist = highlight_left - x
            fade_range = max(highlight_left, 1)
            horiz_fade[x] = (dist / fade_range) ** 0.6
        elif x > highlight_right:
            dist = x - highlight_right
            fade_range = max(w - highlight_right, 1)
            horiz_fade[x] = (dist / fade_range) ** 0.6

    vert_2d = vert_fade[:, np.newaxis]
    horiz_2d = horiz_fade[np.newaxis, :]
    combined = np.maximum(vert_2d, horiz_2d)
    alpha_arr = (combined * max_alpha).clip(0, 255).astype(np.uint8)

    overlay_arr = np.zeros((h, w, 4), dtype=np.uint8)
    overlay_arr[:, :, 0] = fade_color[0]
    overlay_arr[:, :, 1] = fade_color[1]
    overlay_arr[:, :, 2] = fade_color[2]
    overlay_arr[:, :, 3] = alpha_arr
    overlay = Image.fromarray(overlay_arr, "RGBA")
    crop = Image.alpha_composite(crop, overlay)

    # Save
    out_path = OUT_DIR / f"crop_edit_{sid}.png"
    crop.save(out_path)
    print(f"  Saved: {out_path.name} ({crop_w}\u00d7{crop_h})")

    # Context words
    before = line_words[:word_idx]
    matched_word = line_words[word_idx] if word_idx < len(line_words) else consensus
    after = line_words[word_idx + 1:] if word_idx + 1 < len(line_words) else []

    return {
        "sid": sid,
        "cv": cv,
        "consensus": consensus,
        "page": page_id,
        "col": col,
        "line_num": line_num,
        "word_idx": word_idx,
        "before": before,
        "matched_word": matched_word,
        "after": after,
        "img_file": f"crop_edit_{sid}.png",
        "crop_w": crop_w,
        "crop_h": crop_h,
        # Initial bounding box in crop-image relative coords (0\u20131)
        "box_left": round(highlight_left / crop_w, 4),
        "box_right": round(highlight_right / crop_w, 4),
        "box_top": round(box_top / crop_h, 4),
        "box_bot": round(box_bot / crop_h, 4),
        # For converting back to page coordinates (reference px)
        "scaled_crop_left": cl,
        "scaled_crop_top": ct,
        "ref_w": ref_w,
        "ref_h": ref_h,
        "sx": sx,
        "sy": sy,
    }


# ── Generate interactive HTML ──────────────────────────────────────────


def generate_html(results):
    """Build the editor HTML from processed results and open it."""
    # JS-embeddable items data
    items_data = []
    for r in results:
        items_data.append({
            "sid": r["sid"],
            "cv": r["cv"],
            "consensus": r["consensus"],
            "page": r["page"],
            "col": r["col"],
            "lineNum": r["line_num"],
            "wordIdx": r["word_idx"],
            "imgFile": r["img_file"],
            "cropW": r["crop_w"],
            "cropH": r["crop_h"],
            "box": {
                "left": r["box_left"],
                "top": r["box_top"],
                "right": r["box_right"],
                "bottom": r["box_bot"],
            },
            "scaledCropLeft": r["scaled_crop_left"],
            "scaledCropTop": r["scaled_crop_top"],
            "sx": round(r["sx"], 6),
            "sy": round(r["sy"], 6),
        })

    items_json = json.dumps(items_data, ensure_ascii=False)

    # Per-item HTML blocks
    items_html_parts = []
    for i, r in enumerate(results):
        before_joined = join_maqaf(list(r["before"]))
        after_joined = join_maqaf(list(r["after"]))
        target_display = r["matched_word"]
        if before_joined and before_joined[-1].endswith("\u05BE"):
            target_display = before_joined.pop() + target_display
        if target_display.endswith("\u05BE") and after_joined:
            target_display = target_display + after_joined.pop(0)
        before_html = " ".join(before_joined)
        after_html = " ".join(after_joined)

        items_html_parts.append(
            f'<div class="editor-item" data-idx="{i}">\n'
            f'  <h2>{r["sid"]} \u2014 Job {r["cv"]} \u2014 {r["consensus"]}</h2>\n'
            f'  <p class="meta">Page {r["page"]}, col {r["col"]}, '
            f'line {r["line_num"]}, word {r["word_idx"]}</p>\n'
            f'  <div class="crop-box">\n'
            f'    <p class="context">'
            f'<span class="before">{before_html}</span> '
            f'<span class="target">{target_display}</span> '
            f'<span class="after">{after_html}</span></p>\n'
            f'    <div class="img-wrapper" id="wrap-{i}">\n'
            f'      <img id="img-{i}" src="{r["img_file"]}">\n'
            f'      <svg id="svg-{i}" viewBox="0 0 1 1" '
            f'preserveAspectRatio="none"></svg>\n'
            f'    </div>\n'
            f'  </div>\n'
            f'</div>'
        )

    items_html = "\n".join(items_html_parts)

    html = f"""<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Word Crop Editor</title>
<style>
body {{
  background: #222; color: #eee; font-family: sans-serif;
  padding: 10px 20px; margin: 0;
}}

/* ── Toolbar ────────────────────────────────── */
#toolbar {{
  position: sticky; top: 0; z-index: 100;
  background: #333; padding: 8px 12px;
  border-bottom: 1px solid #555;
  display: flex; align-items: center; gap: 12px;
}}
#toolbar button {{
  padding: 6px 14px; cursor: pointer; font-size: 14px;
  border: 1px solid #888; border-radius: 4px;
  background: #444; color: #eee;
}}
#toolbar button.active {{
  background: #668; border-color: #aaf;
}}
#status {{
  font-size: 13px; color: #aaa;
}}

/* ── Items ──────────────────────────────────── */
.editor-item {{
  margin: 20px 0; padding-bottom: 20px;
  border-bottom: 1px solid #444;
}}
.editor-item h2 {{ margin: 5px 0; font-size: 16px; }}
.editor-item.active {{
  border-left: 3px solid #ff4040; padding-left: 10px;
}}
.meta {{
  margin: 2px 0 8px 0; color: #aaa; font-size: 13px;
}}
.crop-box {{ display: inline-block; }}
.context {{
  direction: rtl; unicode-bidi: embed;
  font-size: 20px; margin: 0; padding: 4px 0;
  text-align: center;
  border: 1px solid #555; border-bottom: none;
  background: #2a2a2a;
}}
.context .before, .context .after {{ color: #888; }}
.context .target {{
  color: #fff; background: #553;
  padding: 2px 4px; border-radius: 3px;
}}

/* ── Image + SVG overlay ────────────────────── */
.img-wrapper {{
  position: relative; display: inline-block; line-height: 0;
}}
.img-wrapper img {{
  display: block; border: 1px solid #555;
}}
.img-wrapper svg {{
  position: absolute; top: 0; left: 0;
  width: 100%; height: 100%; pointer-events: none;
}}
.ctrl-point {{
  pointer-events: all !important;
  cursor: grab;
}}
.ctrl-point:hover {{
  fill-opacity: 1;
}}
.ctrl-point.dragging {{
  cursor: grabbing;
}}
</style>
</head>
<body>

<div id="toolbar">
  <button id="fine-btn" class="active" onclick="toggleFine()">Fine</button>
  <button onclick="resetActive()">Reset</button>
  <button onclick="exportJSON()">Export JSON</button>
  <span id="status">Click a handle to begin</span>
</div>

{items_html}

<script>
// ── Data ──────────────────────────────────────
const ITEMS = {items_json};
const N = ITEMS.length;
const FINE_SCALE = 0.2;
let fineMode = true;

// Current box state for each item (0\u20131 relative coords)
const boxes = ITEMS.map(it => ({{
  left:   it.box.left,
  top:    it.box.top,
  right:  it.box.right,
  bottom: it.box.bottom,
}}));
const initBoxes = JSON.parse(JSON.stringify(boxes));

// Active item & side (for keyboard nudge / highlight)
let activeIdx = 0;
let lastSide = 'right';

// Drag state
let dragIdx = -1;
let dragSide = null;
let dragTarget = null;
let dragStartMouse = null;
let dragStartBox = null;

// ── Drawing ───────────────────────────────────

function drawBox(idx) {{
  const svg = document.getElementById('svg-' + idx);
  const b = boxes[idx];
  const bw = b.right - b.left;
  const bh = b.bottom - b.top;
  const isAct = (idx === activeIdx);
  const color = isAct ? '#ff4040' : '#cc3030';
  const hr = isAct ? 0.012 : 0.009;
  const sw = isAct ? 0.005 : 0.003;

  let parts = [];

  // Rectangle
  parts.push(
    '<rect x="' + b.left + '" y="' + b.top + '" ' +
    'width="' + bw + '" height="' + bh + '" ' +
    'fill="none" stroke="' + color + '" stroke-width="' + sw + '" />'
  );

  // Side handles
  const handles = [
    {{ s: 'left',   cx: b.left,               cy: (b.top + b.bottom) / 2 }},
    {{ s: 'right',  cx: b.right,              cy: (b.top + b.bottom) / 2 }},
    {{ s: 'top',    cx: (b.left + b.right) / 2, cy: b.top }},
    {{ s: 'bottom', cx: (b.left + b.right) / 2, cy: b.bottom }},
  ];

  for (const hl of handles) {{
    const cur = (hl.s === 'left' || hl.s === 'right') ? 'ew-resize' : 'ns-resize';
    const fill = (isAct && hl.s === lastSide) ? '#ffff00' : color;
    parts.push(
      '<circle class="ctrl-point" ' +
      'cx="' + hl.cx + '" cy="' + hl.cy + '" r="' + hr + '" ' +
      'fill="' + fill + '" stroke="#fff" stroke-width="0.002" ' +
      'data-idx="' + idx + '" data-side="' + hl.s + '" ' +
      'style="cursor:' + cur + '"/>'
    );
  }}

  svg.innerHTML = parts.join('\\n');
}}

function drawAll() {{
  for (let i = 0; i < N; i++) drawBox(i);
  document.querySelectorAll('.editor-item').forEach((el, i) => {{
    el.classList.toggle('active', i === activeIdx);
  }});
}}

// ── Fine mode ─────────────────────────────────

function toggleFine() {{
  fineMode = !fineMode;
  document.getElementById('fine-btn').classList.toggle('active', fineMode);
  updateStatus();
}}

// ── Drag handlers ─────────────────────────────

window.addEventListener('mousedown', (e) => {{
  const t = e.target;
  if (!t.classList || !t.classList.contains('ctrl-point')) return;
  dragIdx = parseInt(t.dataset.idx);
  dragSide = t.dataset.side;
  dragTarget = t;
  activeIdx = dragIdx;
  lastSide = dragSide;
  t.classList.add('dragging');

  const svg = document.getElementById('svg-' + dragIdx);
  const sr = svg.getBoundingClientRect();
  dragStartMouse = {{
    x: (e.clientX - sr.left) / sr.width,
    y: (e.clientY - sr.top)  / sr.height,
  }};
  dragStartBox = JSON.parse(JSON.stringify(boxes[dragIdx]));
  e.preventDefault();
}});

window.addEventListener('mousemove', (e) => {{
  if (dragIdx < 0) return;
  const svg = document.getElementById('svg-' + dragIdx);
  const sr = svg.getBoundingClientRect();
  let mx = (e.clientX - sr.left) / sr.width;
  let my = (e.clientY - sr.top)  / sr.height;

  if (fineMode) {{
    mx = dragStartMouse.x + (mx - dragStartMouse.x) * FINE_SCALE;
    my = dragStartMouse.y + (my - dragStartMouse.y) * FINE_SCALE;
  }}
  mx = Math.max(0, Math.min(1, mx));
  my = Math.max(0, Math.min(1, my));

  const b0 = dragStartBox;
  const b  = boxes[dragIdx];
  const MIN = 0.02;

  if (dragSide === 'left') {{
    b.left   = Math.min(b0.right - MIN, mx);
    b.right  = b0.right;
    b.top    = b0.top;
    b.bottom = b0.bottom;
  }} else if (dragSide === 'right') {{
    b.right  = Math.max(b0.left + MIN, mx);
    b.left   = b0.left;
    b.top    = b0.top;
    b.bottom = b0.bottom;
  }} else if (dragSide === 'top') {{
    b.top    = Math.min(b0.bottom - MIN, my);
    b.bottom = b0.bottom;
    b.left   = b0.left;
    b.right  = b0.right;
  }} else if (dragSide === 'bottom') {{
    b.bottom = Math.max(b0.top + MIN, my);
    b.top    = b0.top;
    b.left   = b0.left;
    b.right  = b0.right;
  }}

  drawAll();
  updateStatus();
}});

window.addEventListener('mouseup', () => {{
  if (dragIdx >= 0) {{
    if (dragTarget) dragTarget.classList.remove('dragging');
    dragIdx = -1;
    dragTarget = null;
    drawAll();
  }}
}});

// ── Arrow keys ────────────────────────────────

const ARROW_STEP = 0.002;

window.addEventListener('keydown', (e) => {{
  // F toggles fine mode
  if (e.key === 'f' || e.key === 'F') {{ toggleFine(); return; }}

  // Tab / Shift-Tab cycles active item
  if (e.key === 'Tab') {{
    e.preventDefault();
    activeIdx = (activeIdx + (e.shiftKey ? N - 1 : 1)) % N;
    drawAll();
    updateStatus();
    // Scroll active item into view
    const el = document.querySelector('.editor-item[data-idx="' + activeIdx + '"]');
    if (el) el.scrollIntoView({{ behavior: 'smooth', block: 'center' }});
    return;
  }}

  // 1-4 select side: 1=left, 2=right, 3=top, 4=bottom
  if ('1234'.includes(e.key)) {{
    lastSide = ['left', 'right', 'top', 'bottom'][parseInt(e.key) - 1];
    drawAll();
    updateStatus();
    return;
  }}

  if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) return;
  e.preventDefault();

  const step = fineMode ? ARROW_STEP * FINE_SCALE : ARROW_STEP;
  const b = boxes[activeIdx];

  if (lastSide === 'left') {{
    if (e.key === 'ArrowLeft')  b.left = Math.max(0, b.left - step);
    if (e.key === 'ArrowRight') b.left = Math.min(b.right - 0.02, b.left + step);
  }} else if (lastSide === 'right') {{
    if (e.key === 'ArrowLeft')  b.right = Math.max(b.left + 0.02, b.right - step);
    if (e.key === 'ArrowRight') b.right = Math.min(1, b.right + step);
  }} else if (lastSide === 'top') {{
    if (e.key === 'ArrowUp')   b.top = Math.max(0, b.top - step);
    if (e.key === 'ArrowDown') b.top = Math.min(b.bottom - 0.02, b.top + step);
  }} else if (lastSide === 'bottom') {{
    if (e.key === 'ArrowUp')   b.bottom = Math.max(b.top + 0.02, b.bottom - step);
    if (e.key === 'ArrowDown') b.bottom = Math.min(1, b.bottom + step);
  }}

  drawAll();
  updateStatus();
}});

// ── Status ────────────────────────────────────

function updateStatus() {{
  const b = boxes[activeIdx];
  const it = ITEMS[activeIdx];
  const fl = fineMode ? '  [FINE]' : '';
  document.getElementById('status').textContent =
    it.sid + ' (' + lastSide + '): ' +
    'L=' + b.left.toFixed(3) + ' T=' + b.top.toFixed(3) +
    ' R=' + b.right.toFixed(3) + ' B=' + b.bottom.toFixed(3) + fl;
}}

// ── Reset ─────────────────────────────────────

function resetActive() {{
  boxes[activeIdx] = JSON.parse(JSON.stringify(initBoxes[activeIdx]));
  drawAll();
  updateStatus();
}}

// ── Export ─────────────────────────────────────

function r4(v) {{ return Math.round(v * 10000) / 10000; }}

function exportJSON() {{
  const output = [];
  for (let i = 0; i < N; i++) {{
    const it = ITEMS[i];
    const b  = boxes[i];

    // Convert relative crop coords \u2192 page-reference absolute pixels.
    // scaledCropLeft/Top are pixel offsets in the downloaded (scaled) image.
    // Divide by sx/sy to get reference-resolution coordinates.
    const refX = Math.round((it.scaledCropLeft + b.left   * it.cropW) / it.sx);
    const refY = Math.round((it.scaledCropTop  + b.top    * it.cropH) / it.sy);
    const refW = Math.round(((b.right - b.left) * it.cropW) / it.sx);
    const refH = Math.round(((b.bottom - b.top) * it.cropH) / it.sy);

    output.push({{
      sid:      it.sid,
      cv:       it.cv,
      page:     it.page,
      col:      it.col,
      line_num: it.lineNum,
      bbox_ref: {{ x: refX, y: refY, w: refW, h: refH }},
      bbox_rel: {{
        left:   r4(b.left),
        top:    r4(b.top),
        right:  r4(b.right),
        bottom: r4(b.bottom),
      }},
    }});
  }}

  const jsonStr = JSON.stringify(output, null, 2);
  navigator.clipboard.writeText(jsonStr).then(() => {{
    document.getElementById('status').textContent =
      'Exported ' + N + ' items to clipboard!';
    setTimeout(updateStatus, 2000);
  }});
}}

// ── Init ──────────────────────────────────────
drawAll();
updateStatus();
</script>
</body>
</html>
"""

    OUT_DIR.mkdir(exist_ok=True)
    out_path = OUT_DIR / "word_crop_editor.html"
    out_path.write_text(html, encoding="utf-8")
    print(f"\nEditor: {out_path}")
    webbrowser.open(str(out_path))


# ── Main ───────────────────────────────────────────────────────────────


def main():
    pages = load_index()

    use_all = "--all" in sys.argv
    # Collect any positional args (SIDs) from command line
    cli_sids = {a for a in sys.argv[1:] if not a.startswith("-")}

    examples = []
    if use_all:
        # Every quirkrec missing an aleppo image
        for eqr in EQRS:
            sid = short_id(eqr)
            img_path = ROOT / "docs" / "jobn" / "img" / f"Aleppo-{sid}.png"
            if not os.path.exists(img_path):
                examples.append(eqr)
    elif cli_sids:
        # Use SIDs from command line
        for eqr in EQRS:
            sid = short_id(eqr)
            if sid in cli_sids:
                examples.append(eqr)
    else:
        target_sids = {
            "0119", "0303", "0701", "1503", "2001", "3001", "3820", "4003",
        }
        for eqr in EQRS:
            sid = short_id(eqr)
            if sid in target_sids:
                examples.append(eqr)
        # Pad to at least 4 if some targets were not found
        if len(examples) < 4:
            for eqr in EQRS:
                sid = short_id(eqr)
                img_path = ROOT / "docs" / "jobn" / "img" / f"Aleppo-{sid}.png"
                if not os.path.exists(img_path) and eqr not in examples:
                    examples.append(eqr)
                    if len(examples) >= 6:
                        break

    print(f"Processing {len(examples)} quirkrecs...")
    results = []
    for qr in examples:
        try:
            result = process_quirkrec(qr, pages)
            if result:
                results.append(result)
        except Exception as e:
            sid = short_id(qr)
            print(f"  ERROR ({sid}): {e}")
            traceback.print_exc()

    if not results:
        print("No results to display.")
        return

    generate_html(results)


if __name__ == "__main__":
    main()
