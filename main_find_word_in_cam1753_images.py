# Initially generated by GitHub Copilot.
"""
Preview a word on a Cambridge MS Add. 1753 page image.

Given a Hebrew word and a verse reference (e.g. "Job 7:1"), this script:
1. Scans cam1753-line-breaks/*.json to find which page contains the verse
2. Locates the word within the line-break data (page, col, line-num)
3. Gets pixel coordinates from quad data in cam1753-col-quads/
4. Loads the local page image from cam1753-pages/
5. Crops a generous region around the target line with a 2D fade overlay
6. Generates an HTML preview page in .novc/ and opens it

Usage:
    .venv\\Scripts\\python.exe main_find_word_in_cam1753_images.py <book> <c:v> <hebrew_word>

Example:
    .venv\\Scripts\\python.exe main_find_word_in_cam1753_images.py Job 7:1 "וְכִימֵ֖֗י"
"""

import json
import sys
import unicodedata
import webbrowser
from pathlib import Path

import numpy as np
from PIL import Image, ImageDraw

ROOT = Path(__file__).resolve().parent
OUT_DIR = ROOT / ".novc"
LB_DIR = ROOT / "cam1753-line-breaks"
QUAD_DIR = ROOT / "cam1753-col-quads"
IMG_DIR = ROOT / "cam1753-pages"

MAQAF = "\u05be"
LINES_PER_COL = 26


# ---------------------------------------------------------------------------
# Hebrew text helpers (inlined from py_ac_word_image_helper)
# ---------------------------------------------------------------------------


def strip_heb(s):
    """Strip cantillation marks, vowels, and format chars for matching."""
    return "".join(
        ch for ch in s if unicodedata.category(ch) not in ("Mn", "Cf")
    )


def join_maqaf(words):
    """Join maqaf-ending words with the following word. Returns new list."""
    result = []
    for w in words:
        if result and result[-1].endswith(MAQAF):
            result[-1] = result[-1] + w
        else:
            result.append(w)
    return result


# Proportional Hebrew character widths (relative to average = 1.0).
_HEB_W = {
    "\u05d9": 0.4, "\u05d5": 0.5, "\u05df": 0.5,
    "\u05d6": 0.6, "\u05d2": 0.7, "\u05e8": 0.7, "\u05da": 0.7, "\u05e3": 0.7,
    "\u05d1": 0.85, "\u05d3": 0.85, "\u05d4": 0.9, "\u05db": 0.85,
    "\u05dc": 0.7, "\u05e0": 0.7, "\u05e2": 0.9, "\u05e4": 0.9,
    "\u05e5": 0.8, "\u05e6": 0.8, "\u05e7": 0.9, "\u05ea": 0.9,
    "\u05d0": 1.0, "\u05d7": 1.0, "\u05d8": 1.0, "\u05de": 1.0,
    "\u05e1": 1.0, "\u05e9": 1.1, "\u05dd": 1.1,
    "\u05be": 0.6, "\u05c0": 0.3, "\u05c3": 0.3, ":": 0.3,
}
SPACE_WIDTH = 0.5


def _word_width(word):
    w = 0.0
    for ch in word:
        if unicodedata.category(ch) == "Mn":
            continue
        w += _HEB_W.get(ch, 0.85)
    return w


def _line_widths(words):
    ws = [_word_width(w) for w in words]
    return ws, sum(ws) + SPACE_WIDTH * max(0, len(words) - 1)


# ---------------------------------------------------------------------------
# Page and verse lookup
# ---------------------------------------------------------------------------


def find_page_for_verse(book, ch, v):
    """Scan cam1753-line-breaks/ to find the page containing
    <book> <ch>:<v>.  Returns page_id or None."""
    target = f"{book} {ch}:{v}"
    for path in sorted(LB_DIR.glob("*.json")):
        stream = json.loads(path.read_text("utf-8"))
        # Check if this page has the verse with actual words inside
        # line-start/line-end regions (not just empty verse markers).
        in_verse = False
        in_lb = False
        has_words_in_lb = False
        for item in stream:
            if isinstance(item, dict):
                if "line-start" in item:
                    in_lb = True
                if "line-end" in item:
                    in_lb = False
                vs = item.get("verse-start") or item.get("verse-fragment-start")
                ve = item.get("verse-end") or item.get("verse-fragment-end")
                if vs == target:
                    in_verse = True
                if ve == target:
                    in_verse = False
            elif isinstance(item, str) and in_verse and in_lb:
                has_words_in_lb = True
                break
        if has_words_in_lb:
            return path.stem
    return None


def find_word_in_linebreaks(page_id, book, ch, v, consensus):
    """Find a word in cam1753 line-break data.

    Returns (col, line_num, word_index_in_line, line_words).
    """
    lb_path = LB_DIR / f"{page_id}.json"
    stream = json.loads(lb_path.read_text("utf-8"))

    verse_label = f"{book} {ch}:{v}"
    in_verse = False
    cur_col = cur_line = None
    consensus_stripped = strip_heb(consensus)
    consensus_has_maqaf = MAQAF in consensus

    target_col = target_line = None
    match_count = 0
    recent_words = []

    for item in stream:
        if isinstance(item, dict):
            if item.get("verse-start") == verse_label or \
               item.get("verse-fragment-start") == verse_label:
                in_verse = True
                recent_words = []
                continue
            if item.get("verse-end") == verse_label or \
               item.get("verse-fragment-end") == verse_label:
                in_verse = False
                continue
            if "line-start" in item:
                cur_col = item["line-start"]["col"]
                cur_line = item["line-start"]["line-num"]
                continue
        elif isinstance(item, str) and in_verse:
            item_stripped = strip_heb(item)
            matched = (
                item == consensus
                or item_stripped == consensus_stripped
                or (consensus.endswith(MAQAF)
                    and item_stripped == strip_heb(consensus[:-1]))
            )
            if matched:
                match_count += 1
                if match_count == 1:
                    target_col, target_line = cur_col, cur_line
                continue
            if consensus_has_maqaf:
                recent_words.append(item)
                joined = "".join(recent_words)
                if strip_heb(joined) == consensus_stripped or joined == consensus:
                    match_count += 1
                    if match_count == 1:
                        target_col, target_line = cur_col, cur_line
                    continue
                while recent_words and not consensus_stripped.startswith(
                    strip_heb("".join(recent_words))
                ):
                    recent_words.pop(0)

    if match_count > 1:
        raise ValueError(
            f"Ambiguous: {match_count} matches for {consensus!r} in "
            f"{verse_label} on page {page_id}"
        )
    if target_col is None:
        return None, None, None, []

    # Collect all words on the target line
    in_target = False
    line_words = []
    for item in stream:
        if isinstance(item, dict):
            if "line-start" in item:
                ls = item["line-start"]
                if ls["col"] == target_col and ls["line-num"] == target_line:
                    in_target = True
                    line_words = []
                continue
            if "line-end" in item and in_target:
                break
        elif isinstance(item, str) and in_target:
            line_words.append(item)

    # Find word index within the line
    target_idx = None
    for i, w in enumerate(line_words):
        if (w == consensus or strip_heb(w) == consensus_stripped
                or (consensus.endswith(MAQAF)
                    and strip_heb(w) == strip_heb(consensus[:-1]))):
            target_idx = i
            break
        if consensus_has_maqaf and w.endswith(MAQAF):
            joined = w
            for j in range(i + 1, len(line_words)):
                joined += line_words[j]
                if strip_heb(joined) == consensus_stripped or joined == consensus:
                    target_idx = i
                    break
                if not line_words[j].endswith(MAQAF):
                    break
            if target_idx is not None:
                break

    return target_col, target_line, target_idx, line_words


# ---------------------------------------------------------------------------
# Quad-based geometry
# ---------------------------------------------------------------------------


def get_line_bbox(page_id, col, line_num, buffer_lines=2):
    """Get pixel bounding box for a line using quad coordinates.

    Returns (crop_left, crop_top, crop_right, crop_bot,
             target_offset_from_crop_top, line_spacing_px).
    """
    qpath = QUAD_DIR / f"{page_id}.json"
    qdata = json.loads(qpath.read_text("utf-8"))
    img_w, img_h = qdata["image_size"]

    col_key = f"col{col}"
    px = qdata["columns"][col_key]["px"]
    tl, tr, bl, br = px["tl"], px["tr"], px["bl"], px["br"]

    # Line spacing: average height of column / 26 lines
    col_h = ((bl[1] + br[1]) - (tl[1] + tr[1])) / 2
    ls = col_h / LINES_PER_COL

    # Interpolate top-left/right of the target line
    frac = (line_num - 1) / LINES_PER_COL
    frac_bot = line_num / LINES_PER_COL
    line_top_l = tl[1] + (bl[1] - tl[1]) * frac
    line_top_r = tr[1] + (br[1] - tr[1]) * frac
    line_bot_l = tl[1] + (bl[1] - tl[1]) * frac_bot
    line_bot_r = tr[1] + (br[1] - tr[1]) * frac_bot
    line_top = min(line_top_l, line_top_r)
    line_bot = max(line_bot_l, line_bot_r)

    # Column x extents (with margin)
    col_left = min(tl[0], bl[0])
    col_right = max(tr[0], br[0])
    margin_x = int((col_right - col_left) * 0.05)

    crop_top = max(0, int(line_top - buffer_lines * ls))
    crop_bot = min(img_h, int(line_bot + buffer_lines * ls))
    crop_left = max(0, col_left - margin_x)
    crop_right = min(img_w, col_right + margin_x)

    target_offset = int(line_top - crop_top)
    return crop_left, crop_top, crop_right, crop_bot, target_offset, int(ls)


def load_page_image(page_id):
    """Load a cam1753 page image from the local cam1753-pages/ directory."""
    path = IMG_DIR / f"{page_id}.jpg"
    if not path.exists():
        print(f"  ERROR: image not found: {path}")
        sys.exit(1)
    return Image.open(path)


# ---------------------------------------------------------------------------
# Preview generation
# ---------------------------------------------------------------------------


def find_and_preview(word, book, cv):
    """Find *word* in *book* *cv* on cam1753 and generate a preview.

    Returns a dict of result metadata, or None on failure.
    """
    ch, v = (int(x) for x in cv.split(":"))

    print(f"\n=== {book} {cv}: {word} ===")

    page_id = find_page_for_verse(book, ch, v)
    if not page_id:
        print(f"  ERROR: Could not find page for {book} {cv}")
        return None
    print(f"  Page: {page_id}")

    col, line_num, word_idx, line_words = find_word_in_linebreaks(
        page_id, book, ch, v, word
    )
    if col is None:
        print(f"  ERROR: Could not find word in line-break data")
        return None
    print(f"  Location: col {col}, line {line_num}, word {word_idx + 1}")
    print(f"  Line: {' '.join(line_words)}")

    crop_left, crop_top, crop_right, crop_bot, target_offset, ls = get_line_bbox(
        page_id, col, line_num
    )

    img = load_page_image(page_id)
    print(f"  Image: {img.size[0]}x{img.size[1]}")

    crop = img.crop((crop_left, crop_top, crop_right, crop_bot)).convert("RGBA")

    highlight_top = target_offset
    highlight_bot = target_offset + ls

    # Estimate horizontal word position (RTL: word 0 is at right edge)
    word_ws, total_width = _line_widths(line_words)
    if total_width > 0:
        width_before = sum(word_ws[:word_idx]) + SPACE_WIDTH * word_idx
        width_target = word_ws[word_idx] if word_idx < len(word_ws) else 0
        frac_start = width_before / total_width
        frac_end = (width_before + width_target) / total_width
        buffer = 0.15
        frac_left = max(0, frac_start - buffer)
        frac_right = min(1, frac_end + buffer)
        highlight_right = int(crop.width * (1 - frac_left))
        highlight_left = int(crop.width * (1 - frac_right))
    else:
        highlight_left = 0
        highlight_right = crop.width

    # 2D fade overlay
    h, w = crop.height, crop.width
    fade_color = (200, 180, 60)
    max_alpha = 200

    vert_fade = np.zeros(h, dtype=np.float64)
    for y in range(h):
        if y < highlight_top:
            vert_fade[y] = ((highlight_top - y) / max(highlight_top, 1)) ** 0.6
        elif y > highlight_bot:
            vert_fade[y] = ((y - highlight_bot) / max(h - highlight_bot, 1)) ** 0.6

    horiz_fade = np.zeros(w, dtype=np.float64)
    for x in range(w):
        if x < highlight_left:
            horiz_fade[x] = ((highlight_left - x) / max(highlight_left, 1)) ** 0.6
        elif x > highlight_right:
            horiz_fade[x] = ((x - highlight_right) / max(w - highlight_right, 1)) ** 0.6

    combined = np.maximum(
        vert_fade[:, np.newaxis], horiz_fade[np.newaxis, :]
    )
    alpha_arr = (combined * max_alpha).clip(0, 255).astype(np.uint8)

    overlay_arr = np.zeros((h, w, 4), dtype=np.uint8)
    overlay_arr[:, :, 0] = fade_color[0]
    overlay_arr[:, :, 1] = fade_color[1]
    overlay_arr[:, :, 2] = fade_color[2]
    overlay_arr[:, :, 3] = alpha_arr
    yellow_overlay = Image.fromarray(overlay_arr, "RGBA")

    # Red position lines
    red_overlay = Image.new("RGBA", crop.size, (0, 0, 0, 0))
    draw = ImageDraw.Draw(red_overlay)
    half_ls = ls // 2
    box_top = max(0, highlight_top - half_ls)
    box_bot = min(h - 1, highlight_bot + half_ls)
    cx = (highlight_left + highlight_right) // 2
    half_w = max(cx - highlight_left, highlight_right - cx, 1)
    for x_pos in range(highlight_left, highlight_right + 1):
        dist = abs(x_pos - cx)
        a = max(0, int(255 * (1 - dist / half_w)))
        c = (255, 0, 0, a)
        draw.point((x_pos, box_top), fill=c)
        draw.point((x_pos, box_top + 1), fill=c)
        draw.point((x_pos, box_bot), fill=c)
        draw.point((x_pos, box_bot - 1), fill=c)
    tick = min(12, (box_bot - box_top) // 4)
    draw.line([(cx, box_top), (cx, box_top + tick)], fill=(255, 0, 0, 255), width=2)
    draw.line([(cx, box_bot - tick), (cx, box_bot)], fill=(255, 0, 0, 255), width=2)

    # Save 4 image variants
    label = f"{book}_{cv.replace(':', '_')}"
    OUT_DIR.mkdir(exist_ok=True)
    raw_path = OUT_DIR / f"preview_{label}_raw.png"
    crop.save(raw_path)
    crop_y = Image.alpha_composite(crop, yellow_overlay)
    (OUT_DIR / f"preview_{label}.png").parent.mkdir(exist_ok=True)
    crop_y.save(OUT_DIR / f"preview_{label}.png")
    crop_r = Image.alpha_composite(crop, red_overlay)
    crop_r.save(OUT_DIR / f"preview_{label}_red.png")
    crop_yr = Image.alpha_composite(crop_y, red_overlay)
    crop_yr.save(OUT_DIR / f"preview_{label}_yr.png")

    print(f"  Saved: 4 variants as preview_{label}_*.png ({crop.width}x{crop.height})")

    before = line_words[:word_idx]
    matched_word = line_words[word_idx] if word_idx < len(line_words) else word
    after = line_words[word_idx + 1:] if word_idx + 1 < len(line_words) else []
    print(f"  Context: {' '.join(before)} [{matched_word}] {' '.join(after)}")
    return {
        "label": label,
        "book": book,
        "cv": cv,
        "word": word,
        "page": page_id,
        "col": col,
        "line_num": line_num,
        "word_idx": word_idx,
        "before": before,
        "matched_word": matched_word,
        "after": after,
    }


def generate_html(result):
    """Build the preview HTML from a single result and open it."""
    r = result
    before_joined = join_maqaf(list(r["before"]))
    after_joined = join_maqaf(list(r["after"]))
    target_display = r["matched_word"]
    if before_joined and before_joined[-1].endswith(MAQAF):
        target_display = before_joined.pop() + target_display
    if target_display.endswith(MAQAF) and after_joined:
        target_display = target_display + after_joined.pop(0)
    before_html = " ".join(before_joined)
    after_html = " ".join(after_joined)

    html_path = OUT_DIR / "preview_word_crops.html"
    label = r["label"]
    verse_display = f"{r['book']} {r['cv']}"
    with open(html_path, "w", encoding="utf-8") as f:
        f.write(f"""<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Preview \u2014 {verse_display}: {r["word"]}</title>
<style>
body {{ background: #222; color: #eee; font-family: sans-serif; padding: 20px; }}
.preview img {{ border: 1px solid #555; display: block; }}
.preview h2 {{ margin-bottom: 5px; }}
.preview .meta {{ margin-top: 2px; color: #aaa; font-size: 14px; }}
.crop-box {{ display: inline-block; }}
.context {{ direction: rtl; unicode-bidi: embed; font-size: 22px; margin: 0; padding: 6px 0; text-align: center; border: 1px solid #555; border-bottom: none; background: #2a2a2a; }}
.context .before, .context .after {{ color: #888; }}
.context .target {{ color: #fff; background: #553; padding: 2px 4px; border-radius: 3px; }}
</style>
</head>
<body>
<h1>cam1753 Word Preview</h1>
<p>Yellow fade marks surrounding lines; clear band = target line.</p>
<p>
<button id="toggle-yellow" onclick="toggleYellow()">Hide yellow fade</button>
<button id="toggle-red" onclick="toggleRed()">Hide red position lines</button>
</p>
<script>
let showYellow = true;
let showRed = true;
function pickSrc(img) {{
  const key = (showYellow ? 'y' : '') + (showRed ? 'r' : '');
  img.src = img.dataset[key || 'raw'];
}}
function toggleYellow() {{
  showYellow = !showYellow;
  document.getElementById('toggle-yellow').textContent = showYellow ? 'Hide yellow fade' : 'Show yellow fade';
  document.querySelectorAll('.crop-img').forEach(pickSrc);
}}
function toggleRed() {{
  showRed = !showRed;
  document.getElementById('toggle-red').textContent = showRed ? 'Hide red position lines' : 'Show red position lines';
  document.querySelectorAll('.crop-img').forEach(pickSrc);
}}
</script>
<div class="preview">
<h2>{verse_display} \u2014 {r["word"]}</h2>
<p class="meta">Page {r["page"]}, col {r["col"]}, line {r["line_num"]}, word {r["word_idx"] + 1}</p>
<div class="crop-box">
<p class="context"><span class="before">{before_html}</span> <span class="target">{target_display}</span> <span class="after">{after_html}</span></p>
<img class="crop-img" src="preview_{label}_yr.png" data-raw="preview_{label}_raw.png" data-y="preview_{label}.png" data-r="preview_{label}_red.png" data-yr="preview_{label}_yr.png">
</div>
</div>
</body></html>
""")
    print(f"\nHTML: {html_path}")
    webbrowser.open(str(html_path))


def main():
    if len(sys.argv) != 4:
        print(
            "Usage: .venv\\Scripts\\python.exe"
            " main_find_word_in_cam1753_images.py <book> <c:v> <hebrew_word>"
        )
        print("Example: ... Job 7:1 \"\u05d5\u05b0\u05db\u05b4\u05d9\u05de\u05b5\u05d9\"")
        sys.exit(1)

    book = sys.argv[1]
    cv = sys.argv[2]
    word = sys.argv[3]
    if ":" not in cv:
        print(f"ERROR: verse must be in c:v format (e.g. 7:1), got: {cv}")
        sys.exit(1)

    result = find_and_preview(word, book, cv)
    if result:
        generate_html(result)
    else:
        sys.exit(1)


if __name__ == "__main__":
    main()
