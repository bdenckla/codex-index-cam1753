# Initially generated by GitHub Copilot.
"""
Check that every Hebrew word in tracked .py and .json files has the
project\u2019s standard combining-mark order (SBL2 / \u201Cour\u201D order):

    base letter \u2192 shin/sin dot \u2192 dagesh \u2192 rafeh \u2192 (everything else unchanged)

The canonical reordering function ``give_std_mark_order`` is inlined here
from book-of-job/pycmn/uni_denorm.py so this repo stays self-contained.

A \u201CHebrew word\u201D is any maximal run matched by the regex:

    WORD_RE = r"[\u0590-\u05FF\u034F\uFB1E]+"

i.e. one or more characters from the Hebrew block (U+0590\u2013U+05FF),
plus Combining Grapheme Joiner (U+034F) and Varika (U+FB1E).  Words that
contain no Hebrew *letter* (U+05D0\u2013U+05EA) are skipped.

Exit codes:
  0 \u2013 All files pass
  1 \u2013 One or more violations found
"""

import re
import sys
from pathlib import Path

# ── regex definitions ────────────────────────────────────────────────

# A "Hebrew word": maximal run of Hebrew-block chars + CGJ + Varika.
WORD_RE = re.compile(r"[\u0590-\u05FF\u034F\uFB1E]+")

# At least one Hebrew letter (alef through tav).
HAS_LETTER_RE = re.compile(r"[\u05D0-\u05EA]")

# A cluster: base letter + zero or more combining marks from the
# Hebrew block (U+0591–U+05C7), CGJ (U+034F), and Varika (U+FB1E).
_CLUSTER_RE = re.compile(r"[\u05D0-\u05EA][\u0591-\u05C7\u034F\uFB1E]*")

# ── SBL2 mark-order sort key ────────────────────────────────────────

_SORT_KEYS = {
    "\u05C1": 10,  # shin dot
    "\u05C2": 11,  # sin dot
    "\u05BC": 21,  # dagesh / mapiq / shuruq dot
    "\u05BF": 23,  # rafeh
}


def _sort_key(ch):
    return _SORT_KEYS.get(ch, 300)


def _repl_cluster(match):
    """Sort the combining marks within one base-letter cluster."""
    full = match.group()
    letter, marks = full[0], full[1:]
    return letter + "".join(sorted(marks, key=_sort_key))


def give_std_mark_order(s):
    """Return *s* with combining marks reordered to project standard order.

    Shin/sin dot → dagesh → rafeh come first (in that order);
    all other marks keep their original relative order (stable sort at
    key 300).
    """
    return _CLUSTER_RE.sub(_repl_cluster, s)


# ── file discovery ──────────────────────────────────────────────────

_SKIP_DIRS = {".venv", "__pycache__", ".novc", ".git", "node_modules"}


def _tracked_files(root):
    """Yield .py and .json paths under *root*, skipping non-tracked dirs."""
    for p in sorted(root.rglob("*")):
        if any(part in _SKIP_DIRS for part in p.parts):
            continue
        if p.is_file() and p.suffix in (".py", ".json"):
            yield p


# ── checking logic ──────────────────────────────────────────────────


def check_file(path, root):
    """Return list of (rel_path, line_no, original, reordered) tuples."""
    violations = []
    try:
        text = path.read_text(encoding="utf-8")
    except (UnicodeDecodeError, OSError) as exc:
        print(f"  WARNING: could not read {path.relative_to(root)}: {exc}")
        return violations

    for line_no, line in enumerate(text.splitlines(), 1):
        for m in WORD_RE.finditer(line):
            word = m.group()
            if not HAS_LETTER_RE.search(word):
                continue
            fixed = give_std_mark_order(word)
            if fixed != word:
                violations.append(
                    (str(path.relative_to(root)), line_no, word, fixed)
                )
    return violations


def main():
    root = Path(__file__).resolve().parent
    all_violations = []

    files = list(_tracked_files(root))
    for path in files:
        all_violations.extend(check_file(path, root))

    if all_violations:
        print(f"FAIL: {len(all_violations)} word(s) with non-standard mark order:\n")
        for rel, line_no, orig, fixed in all_violations:
            # Show codepoint sequences for clarity.
            orig_cp = " ".join(f"U+{ord(c):04X}" for c in orig)
            fixed_cp = " ".join(f"U+{ord(c):04X}" for c in fixed)
            print(f"  {rel}:{line_no}")
            print(f"    original : {orig}  [{orig_cp}]")
            print(f"    expected : {fixed}  [{fixed_cp}]")
            print()
        return 1

    print(f"OK: all Hebrew words in {len(files)} files have standard mark order.")
    return 0


if __name__ == "__main__":
    sys.exit(main())
