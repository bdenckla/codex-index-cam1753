# Initially generated by GitHub Copilot.
"""
Generate an interactive HTML editor for adjusting column bounding
quadrilaterals on a Cambridge MS Add. 1753 page image.

Shows the page image with two draggable quadrilaterals (one per column).
Each quad has 4 freely-movable corners. 26 evenly-spaced lines are
interpolated within each quad. Export produces JSON with corner
coordinates (both relative and pixel).

The image is loaded from a local file (cam1753-pages/<page>.jpg).

Usage:
    .venv\\Scripts\\python.exe gen_col_quad_editor.py 0073B
"""

import json
import sys
import webbrowser
from pathlib import Path

BASE = Path(__file__).resolve().parent
OUT_DIR = BASE / ".novc"
COORD_DIR = BASE / "cam1753-col-quads"
IMG_DIR = BASE / "cam1753-pages"

LINES_PER_COL = 26


def _average_saved_quads(is_verso):
    """Average the rel coords of all saved quads for the same page type."""
    matching = []
    for f in COORD_DIR.glob("*.json"):
        pid = f.stem
        if (pid.endswith("B")) == is_verso:
            data = json.loads(f.read_text(encoding="utf-8"))
            cols = {}
            for col_key in ("col1", "col2"):
                src = data["columns"][col_key]
                rel = src.get("rel", src)
                cols[col_key] = {c: rel[c] for c in ("tl", "tr", "bl", "br")}
            matching.append(cols)
    if not matching:
        return None
    # Average each corner coordinate across all matching pages
    avg = {}
    for col_key in ("col1", "col2"):
        avg[col_key] = {}
        for corner in ("tl", "tr", "bl", "br"):
            xs = [m[col_key][corner][0] for m in matching]
            ys = [m[col_key][corner][1] for m in matching]
            avg[col_key][corner] = [
                round(sum(xs) / len(xs), 4),
                round(sum(ys) / len(ys), 4),
            ]
    return avg


def _load_defaults(page_id):
    """Load saved quad coordinates if they exist, else use averaged defaults."""
    coord_file = COORD_DIR / f"{page_id}.json"
    if coord_file.exists():
        data = json.loads(coord_file.read_text(encoding="utf-8"))
        # Extract rel coords into the flat format the template expects
        cols = {}
        for col_key in ("col1", "col2"):
            src = data["columns"][col_key]
            # Support both nested (rel/px) and flat formats
            rel = src.get("rel", src)
            cols[col_key] = {
                "tl": rel["tl"],
                "tr": rel["tr"],
                "bl": rel["bl"],
                "br": rel["br"],
            }
        return {"page": page_id, "columns": cols}, True

    is_verso = page_id.endswith("B")

    # Try to average existing saved quads for the same page type
    avg = _average_saved_quads(is_verso)
    if avg:
        return {"page": page_id, "columns": avg}, False

    # Hardcoded fallback if no saved data exists at all
    # RTL reading order: col1 = RIGHT column (read first),
    #                     col2 = LEFT column (read second).
    if is_verso:
        defaults = {
            "col1": {
                "tl": [0.50, 0.09],
                "tr": [0.84, 0.09],
                "bl": [0.50, 0.86],
                "br": [0.84, 0.86],
            },
            "col2": {
                "tl": [0.03, 0.09],
                "tr": [0.37, 0.09],
                "bl": [0.03, 0.86],
                "br": [0.37, 0.86],
            },
        }
    else:
        defaults = {
            "col1": {
                "tl": [0.63, 0.09],
                "tr": [0.97, 0.09],
                "bl": [0.63, 0.86],
                "br": [0.97, 0.86],
            },
            "col2": {
                "tl": [0.16, 0.09],
                "tr": [0.50, 0.09],
                "bl": [0.16, 0.86],
                "br": [0.50, 0.86],
            },
        }
    return {"page": page_id, "columns": defaults}, False


def generate_editor(page_id):
    """Generate the HTML quad editor for a page."""
    img_path = IMG_DIR / f"{page_id}.jpg"
    if not img_path.exists():
        print(f"Error: image not found: {img_path}")
        sys.exit(1)

    # Get image dimensions
    from PIL import Image

    with Image.open(img_path) as im:
        img_w, img_h = im.size

    # Image served via local HTTP server rooted at repo dir
    img_url = f"http://localhost:8119/cam1753-pages/{page_id}.jpg"

    data, from_file = _load_defaults(page_id)
    c1 = data["columns"]["col1"]
    c2 = data["columns"]["col2"]
    source_note = (
        f"cam1753-col-quads/{page_id}.json"
        if from_file
        else "averaged from saved pages"
    )

    is_verso = page_id.endswith("B")

    html = f"""\
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Column Quad Editor — {page_id}</title>
<style>
  * {{ margin: 0; padding: 0; box-sizing: border-box; }}
  body {{
    background: #222;
    color: #eee;
    font-family: system-ui, sans-serif;
    overflow: hidden;
  }}
  #toolbar {{
    position: fixed;
    top: 0; left: 0; right: 0;
    height: 40px;
    background: #333;
    display: flex;
    align-items: center;
    padding: 0 12px;
    gap: 10px;
    z-index: 100;
    font-size: 13px;
  }}
  #toolbar button {{
    padding: 4px 12px;
    cursor: pointer;
    border: 1px solid #666;
    background: #444;
    color: #eee;
    border-radius: 3px;
    font-size: 13px;
  }}
  #toolbar button:hover {{ background: #555; }}
  #toolbar button.active {{ background: #070; border-color: #0a0; }}
  .info {{ color: #aaa; font-size: 12px; }}
  #container {{
    position: absolute;
    top: 40px; left: 0; right: 0; bottom: 0;
    overflow: auto;
  }}
  #page-wrapper {{
    position: relative;
    display: block;
    width: fit-content;
    margin: 0 auto;
  }}
  #page-wrapper img {{
    display: block;
    height: calc(100vh - 40px);
    width: auto;
  }}
  #overlay {{
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    pointer-events: none;
  }}
  #overlay svg {{
    width: 100%;
    height: 100%;
  }}
  .handle {{
    pointer-events: all;
    cursor: grab;
  }}
  .handle:hover {{ opacity: 1; }}
  .handle.dragging {{ cursor: grabbing; }}
  .toast {{
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: #070;
    color: #fff;
    padding: 8px 24px;
    border-radius: 4px;
    font-size: 14px;
    z-index: 200;
    opacity: 0;
    transition: opacity 0.3s;
  }}
  .toast.show {{ opacity: 1; }}
</style>
</head>
<body>

<div id="toolbar">
  <span><b>Quad Editor</b> — {page_id}</span>
  <button id="fine-btn" onclick="toggleFine()" class="active">Fine: ON</button>
  <button onclick="resetPositions()">Reset</button>
  <button onclick="exportJSON()" style="background:#046;border-color:#08f">Export JSON</button>
  <span class="info">Source: {source_note} | Image: {img_w}×{img_h}</span>
  <span class="info" id="status" style="margin-left:auto"></span>
</div>

<div id="container">
  <div id="page-wrapper">
    <img id="page-img" src="{img_url}" alt="Page {page_id}">
    <div id="overlay">
      <svg id="svg" viewBox="0 0 1 1" preserveAspectRatio="none"></svg>
    </div>
  </div>
</div>

<div id="toast" class="toast"></div>

<script>
"use strict";

const PAGE = "{page_id}";
const IMG_W = {img_w};
const IMG_H = {img_h};
const N_LINES = {LINES_PER_COL};
const IS_VERSO = {'true' if is_verso else 'false'};
const FINE_SCALE = 0.15;

// Column data: each has tl, tr, bl, br as [x,y] in relative coords (0-1)
const DEFAULTS = {{
  col1: {{
    tl: [{c1['tl'][0]}, {c1['tl'][1]}],
    tr: [{c1['tr'][0]}, {c1['tr'][1]}],
    bl: [{c1['bl'][0]}, {c1['bl'][1]}],
    br: [{c1['br'][0]}, {c1['br'][1]}],
  }},
  col2: {{
    tl: [{c2['tl'][0]}, {c2['tl'][1]}],
    tr: [{c2['tr'][0]}, {c2['tr'][1]}],
    bl: [{c2['bl'][0]}, {c2['bl'][1]}],
    br: [{c2['br'][0]}, {c2['br'][1]}],
  }},
}};

let cols = JSON.parse(JSON.stringify(DEFAULTS));
let fineMode = true;

const svg = document.getElementById('svg');
const statusEl = document.getElementById('status');
const toastEl = document.getElementById('toast');

function toggleFine() {{
  fineMode = !fineMode;
  const btn = document.getElementById('fine-btn');
  btn.textContent = fineMode ? 'Fine: ON' : 'Fine: OFF';
  btn.classList.toggle('active', fineMode);
}}

function resetPositions() {{
  cols = JSON.parse(JSON.stringify(DEFAULTS));
  drawAll();
}}

function showToast(msg) {{
  toastEl.textContent = msg;
  toastEl.classList.add('show');
  setTimeout(() => toastEl.classList.remove('show'), 2000);
}}

// Bilinear interpolation within the quad for line endpoints.
// t = 0 at top edge, t = 1 at bottom edge.
// Returns {{left: [x,y], right: [x,y]}} in relative coords.
function lineEndpoints(q, t) {{
  // Left edge: lerp(tl, bl, t); Right edge: lerp(tr, br, t)
  return {{
    left:  [q.tl[0] + t * (q.bl[0] - q.tl[0]),
            q.tl[1] + t * (q.bl[1] - q.tl[1])],
    right: [q.tr[0] + t * (q.br[0] - q.tr[0]),
            q.tr[1] + t * (q.br[1] - q.tr[1])],
  }};
}}

function drawAll() {{
  while (svg.firstChild) svg.removeChild(svg.firstChild);

  for (const [colName, q] of Object.entries(cols)) {{
    const colNum = colName === 'col1' ? 1 : 2;
    const colour = colNum === 1 ? 'rgba(255, 70, 70, 0.8)' : 'rgba(70, 140, 255, 0.8)';
    const fillColour = colNum === 1 ? 'rgba(255, 70, 70, 0.06)' : 'rgba(70, 140, 255, 0.06)';
    const handleFill = colNum === 1 ? '#f44' : '#48f';

    // Quad outline (filled lightly)
    const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
    const pts = [q.tl, q.tr, q.br, q.bl].map(p => p.join(',')).join(' ');
    poly.setAttribute('points', pts);
    poly.setAttribute('fill', fillColour);
    poly.setAttribute('stroke', colour);
    poly.setAttribute('stroke-width', '0.002');
    poly.setAttribute('stroke-dasharray', '0.008 0.004');
    svg.appendChild(poly);

    // 26 line-boxes with variable heights:
    // Box 0 (top) = 1.5x normal, box 25 (bottom) = 1.25x normal,
    // boxes 1-24 = 1x normal. This accounts for lamed ascenders at
    // top and descenders at bottom of the bounding quad.
    const TOP_WEIGHT = 1.5;
    const BOT_WEIGHT = 1.25;
    const MID_COUNT = N_LINES - 2;  // 24 normal boxes
    const totalWeight = TOP_WEIGHT + MID_COUNT + BOT_WEIGHT;

    // Compute t values for each divider (0 = top edge, N_LINES = bottom edge)
    // dividerT[i] = cumulative weight up to divider i, normalized to 0-1.
    const dividerT = [0];
    for (let i = 0; i < N_LINES; i++) {{
      const w = i === 0 ? TOP_WEIGHT : i === N_LINES - 1 ? BOT_WEIGHT : 1;
      dividerT.push(dividerT[i] + w / totalWeight);
    }}

    for (let i = 1; i < N_LINES; i++) {{
      const t = dividerT[i];
      const ep = lineEndpoints(q, t);
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', ep.left[0]);
      line.setAttribute('y1', ep.left[1]);
      line.setAttribute('x2', ep.right[0]);
      line.setAttribute('y2', ep.right[1]);
      line.setAttribute('stroke', colour);
      line.setAttribute('stroke-width', '0.001');
      line.setAttribute('opacity', '0.5');
      svg.appendChild(line);
    }}

    // Label each of the 26 line-boxes (spaces between dividers)
    for (let i = 0; i < N_LINES; i++) {{
      const tMid = (dividerT[i] + dividerT[i + 1]) / 2;
      const ep = lineEndpoints(q, tMid);
      const labelPt = colNum === 1 ? ep.left : ep.right;
      const nudge = colNum === 1 ? -0.012 : 0.012;
      const anchor = colNum === 1 ? 'end' : 'start';
      const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      label.setAttribute('x', labelPt[0] + nudge);
      label.setAttribute('y', labelPt[1] + 0.004);
      label.setAttribute('text-anchor', anchor);
      label.setAttribute('font-size', '0.009');
      label.setAttribute('fill', colour);
      label.textContent = String(i + 1);
      svg.appendChild(label);
    }}

    // Corner handles
    for (const corner of ['tl', 'tr', 'bl', 'br']) {{
      const [cx, cy] = q[corner];
      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('cx', cx);
      circle.setAttribute('cy', cy);
      circle.setAttribute('r', '0.008');
      circle.setAttribute('fill', handleFill);
      circle.setAttribute('stroke', '#fff');
      circle.setAttribute('stroke-width', '0.001');
      circle.setAttribute('class', 'handle');
      circle.dataset.col = colName;
      circle.dataset.corner = corner;
      circle.addEventListener('mouseenter', () => circle.setAttribute('r', '0.012'));
      circle.addEventListener('mouseleave', () => circle.setAttribute('r', '0.008'));
      svg.appendChild(circle);

      // Corner label
      const cLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      const lx = corner.includes('l') ? cx - 0.015 : cx + 0.015;
      const ly = corner.includes('t') ? cy - 0.012 : cy + 0.018;
      const la = corner.includes('l') ? 'end' : 'start';
      cLabel.setAttribute('x', lx);
      cLabel.setAttribute('y', ly);
      cLabel.setAttribute('text-anchor', la);
      cLabel.setAttribute('font-size', '0.009');
      cLabel.setAttribute('fill', '#fff');
      cLabel.setAttribute('opacity', '0.5');
      cLabel.textContent = `C${{colNum}} ${{corner.toUpperCase()}}`;
      svg.appendChild(cLabel);
    }}

    // Edge midpoint handles — drag moves both corners of that edge
    const edges = [
      {{ name: 'top',    corners: ['tl', 'tr'] }},
      {{ name: 'bottom', corners: ['bl', 'br'] }},
      {{ name: 'left',   corners: ['tl', 'bl'] }},
      {{ name: 'right',  corners: ['tr', 'br'] }},
    ];
    for (const edge of edges) {{
      const [c1, c2] = edge.corners;
      const mx = (q[c1][0] + q[c2][0]) / 2;
      const my = (q[c1][1] + q[c2][1]) / 2;
      const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      const rw = 0.016, rh = 0.011;
      rect.setAttribute('x', mx - rw / 2);
      rect.setAttribute('y', my - rh / 2);
      rect.setAttribute('width', rw);
      rect.setAttribute('height', rh);
      rect.setAttribute('rx', '0.002');
      rect.setAttribute('fill', handleFill);
      rect.setAttribute('stroke', '#fff');
      rect.setAttribute('stroke-width', '0.0008');
      rect.setAttribute('opacity', '0.7');
      rect.setAttribute('class', 'handle');
      rect.dataset.col = colName;
      rect.dataset.edge = edge.name;
      rect.dataset.corners = edge.corners.join(',');
      rect.addEventListener('mouseenter', () => rect.setAttribute('opacity', '1'));
      rect.addEventListener('mouseleave', () => rect.setAttribute('opacity', '0.7'));
      svg.appendChild(rect);
    }}

    // Center handle — drag moves all 4 corners at once
    const cx = (q.tl[0] + q.tr[0] + q.bl[0] + q.br[0]) / 4;
    const cy = (q.tl[1] + q.tr[1] + q.bl[1] + q.br[1]) / 4;
    const cRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    const cw = 0.020, ch = 0.014;
    cRect.setAttribute('x', cx - cw / 2);
    cRect.setAttribute('y', cy - ch / 2);
    cRect.setAttribute('width', cw);
    cRect.setAttribute('height', ch);
    cRect.setAttribute('rx', '0.003');
    cRect.setAttribute('fill', handleFill);
    cRect.setAttribute('stroke', '#fff');
    cRect.setAttribute('stroke-width', '0.001');
    cRect.setAttribute('opacity', '0.5');
    cRect.setAttribute('class', 'handle');
    cRect.dataset.col = colName;
    cRect.dataset.edge = 'center';
    cRect.dataset.corners = 'tl,tr,bl,br';
    cRect.addEventListener('mouseenter', () => cRect.setAttribute('opacity', '0.9'));
    cRect.addEventListener('mouseleave', () => cRect.setAttribute('opacity', '0.5'));
    svg.appendChild(cRect);

    // Column label
    const midX = (q.tl[0] + q.tr[0]) / 2;
    const topY = Math.min(q.tl[1], q.tr[1]) - 0.02;
    const colLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    colLabel.setAttribute('x', midX);
    colLabel.setAttribute('y', topY);
    colLabel.setAttribute('text-anchor', 'middle');
    colLabel.setAttribute('font-size', '0.016');
    colLabel.setAttribute('font-weight', 'bold');
    colLabel.setAttribute('fill', colour);
    colLabel.textContent = `Column ${{colNum}}`;
    svg.appendChild(colLabel);
  }}
}}

// ── Dragging ─────────────────────────────────────────────────────────

let dragInfo = null; // col, corners[], startPts, startMouse

function getSvgCoords(e) {{
  const rect = svg.getBoundingClientRect();
  return [
    (e.clientX - rect.left) / rect.width,
    (e.clientY - rect.top) / rect.height,
  ];
}}

svg.addEventListener('mousedown', (e) => {{
  const el = e.target;
  if (!el.classList.contains('handle')) return;
  e.preventDefault();
  const col = el.dataset.col;
  const [mx, my] = getSvgCoords(e);

  // Determine which corners this handle controls
  let corners;
  if (el.dataset.corner) {{
    corners = [el.dataset.corner];
  }} else if (el.dataset.corners) {{
    corners = el.dataset.corners.split(',');
  }} else {{
    return;
  }}

  const startPts = {{}};
  for (const c of corners) {{
    startPts[c] = [...cols[col][c]];
  }}

  dragInfo = {{
    col,
    corners,
    startPts,
    startMouse: [mx, my],
    el,
    edge: el.dataset.edge || null,
  }};
  el.classList.add('dragging');
}});

window.addEventListener('mousemove', (e) => {{
  if (!dragInfo) return;
  e.preventDefault();
  const [mx, my] = getSvgCoords(e);
  let dx = mx - dragInfo.startMouse[0];
  let dy = my - dragInfo.startMouse[1];
  if (fineMode) {{ dx *= FINE_SCALE; dy *= FINE_SCALE; }}

  for (const c of dragInfo.corners) {{
    cols[dragInfo.col][c] = [
      dragInfo.startPts[c][0] + dx,
      dragInfo.startPts[c][1] + dy,
    ];
  }}

  drawAll();
  // Preserve dragging state on the new handle element
  const handles = svg.querySelectorAll('.handle');
  for (const h of handles) {{
    const match = dragInfo.edge
      ? (h.dataset.col === dragInfo.col && h.dataset.edge === dragInfo.edge)
      : (h.dataset.col === dragInfo.col && h.dataset.corner === dragInfo.corners[0]);
    if (match) {{
      h.classList.add('dragging');
      dragInfo.el = h;
      break;
    }}
  }}
  updateStatus();
}});

window.addEventListener('mouseup', () => {{
  if (dragInfo) {{
    dragInfo.el.classList.remove('dragging');
    // Track last-touched handle for arrow key nudging
    activeCol = dragInfo.col;
    activeCorners = dragInfo.corners;
    updateStatus();
    dragInfo = null;
  }}
}});

// ── Keyboard nudge ───────────────────────────────────────────────────
// Arrow keys nudge the nearest handle. Tab cycles active column.
let activeCol = 'col1';
let activeCorners = ['tl'];  // list of corners to nudge together

window.addEventListener('keydown', (e) => {{
  const step = fineMode ? 0.001 : 0.005;
  const k = e.key;

  if (k === 'f' || k === 'F') {{
    toggleFine();
    return;
  }}

  if (k === 'Tab') {{
    e.preventDefault();
    // Cycle: col1 tl -> tr -> bl -> br -> col2 tl -> ...
    const corners = ['tl', 'tr', 'bl', 'br'];
    let ci = corners.indexOf(activeCorners[0]);
    ci++;
    if (ci >= corners.length) {{
      ci = 0;
      activeCol = activeCol === 'col1' ? 'col2' : 'col1';
    }}
    activeCorners = [corners[ci]];
    updateStatus();
    return;
  }}

  let dx = 0, dy = 0;
  if (k === 'ArrowLeft') dx = -step;
  else if (k === 'ArrowRight') dx = step;
  else if (k === 'ArrowUp') dy = -step;
  else if (k === 'ArrowDown') dy = step;
  else return;

  e.preventDefault();
  for (const ac of activeCorners) {{
    const pt = cols[activeCol][ac];
    pt[0] += dx;
    pt[1] += dy;
  }}
  drawAll();
  updateStatus();
}});

function updateStatus() {{
  const q = cols[activeCol];
  const labels = activeCorners.map(c => c.toUpperCase()).join('+');
  const pt = q[activeCorners[0]];
  statusEl.textContent = `Active: ${{activeCol}} ${{labels}} (${{(pt[0]).toFixed(4)}}, ${{(pt[1]).toFixed(4)}}) | Arrow keys to nudge, Tab to cycle`;
}}

// ── Export ────────────────────────────────────────────────────────────

function exportJSON() {{
  const round4 = (v) => Math.round(v * 10000) / 10000;
  const toPx = ([rx, ry]) => [Math.round(rx * IMG_W), Math.round(ry * IMG_H)];

  const result = {{
    page: PAGE,
    image_size: [IMG_W, IMG_H],
    columns: {{}},
  }};

  for (const [colName, q] of Object.entries(cols)) {{
    result.columns[colName] = {{
      rel: {{
        tl: [round4(q.tl[0]), round4(q.tl[1])],
        tr: [round4(q.tr[0]), round4(q.tr[1])],
        bl: [round4(q.bl[0]), round4(q.bl[1])],
        br: [round4(q.br[0]), round4(q.br[1])],
      }},
      px: {{
        tl: toPx(q.tl),
        tr: toPx(q.tr),
        bl: toPx(q.bl),
        br: toPx(q.br),
      }},
    }};
  }}

  const jsonStr = JSON.stringify(result, null, 2);
  navigator.clipboard.writeText(jsonStr).then(() => {{
    showToast('JSON copied to clipboard!');
  }}).catch(() => {{
    // Fallback: open in a prompt
    prompt('Copy this JSON:', jsonStr);
  }});
}}

// ── Init ─────────────────────────────────────────────────────────────
drawAll();
updateStatus();
</script>
</body>
</html>
"""

    out_path = OUT_DIR / f"quad-editor-{page_id}.html"
    OUT_DIR.mkdir(exist_ok=True)
    out_path.write_text(html, encoding="utf-8")
    print(f"Editor written to: {out_path}")


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python gen_col_quad_editor.py <page_id>")
        print("  e.g.: python gen_col_quad_editor.py 0073B")
        sys.exit(1)
    generate_editor(sys.argv[1])
