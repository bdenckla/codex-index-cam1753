# Initially generated by GitHub Copilot.
"""
Preview a word on a Cambridge MS Add. 1753 page image.

Given a Hebrew word and a verse reference (e.g. "Job 7:1"), this script:
1. Scans cam1753-line-breaks/*.json to find which page contains the verse
2. Locates the word within the line-break data (page, col, line-num)
3. Gets pixel coordinates from quad data in cam1753-col-quads/
4. Loads the local page image from cam1753-pages/
5. Crops a generous region around the target line with a 2D fade overlay
6. Generates an HTML preview page in .novc/ and opens it

Usage:
    .venv\\Scripts\\python.exe main_find_word_in_cam1753_images.py <book> <c:v> <hebrew_word>

Example:
    .venv\\Scripts\\python.exe main_find_word_in_cam1753_images.py Job 7:1 "וְכִימֵ֖֗י"
"""

import json
import sys
import unicodedata
import webbrowser
from pathlib import Path

import numpy as np
from PIL import Image, ImageDraw

ROOT = Path(__file__).resolve().parent
OUT_DIR = ROOT / ".novc"
LB_DIR = ROOT / "cam1753-line-breaks"
QUAD_DIR = ROOT / "cam1753-col-quads"
IMG_DIR = ROOT / "cam1753-pages"

MAQAF = "\u05be"
LINES_PER_COL = 26


# ---------------------------------------------------------------------------
# Hebrew text helpers (inlined from py_ac_word_image_helper)
# ---------------------------------------------------------------------------


def strip_heb(s):
    """Strip cantillation marks, vowels, and format chars for matching."""
    return "".join(
        ch for ch in s if unicodedata.category(ch) not in ("Mn", "Cf")
    )


def join_maqaf(words):
    """Join maqaf-ending words with the following word. Returns new list."""
    result = []
    for w in words:
        if result and result[-1].endswith(MAQAF):
            result[-1] = result[-1] + w
        else:
            result.append(w)
    return result


# Proportional Hebrew character widths (relative to average = 1.0).
_HEB_W = {
    "\u05d9": 0.4, "\u05d5": 0.5, "\u05df": 0.5,
    "\u05d6": 0.6, "\u05d2": 0.7, "\u05e8": 0.7, "\u05da": 0.7, "\u05e3": 0.7,
    "\u05d1": 0.85, "\u05d3": 0.85, "\u05d4": 0.9, "\u05db": 0.85,
    "\u05dc": 0.7, "\u05e0": 0.7, "\u05e2": 0.9, "\u05e4": 0.9,
    "\u05e5": 0.8, "\u05e6": 0.8, "\u05e7": 0.9, "\u05ea": 0.9,
    "\u05d0": 1.0, "\u05d7": 1.0, "\u05d8": 1.0, "\u05de": 1.0,
    "\u05e1": 1.0, "\u05e9": 1.1, "\u05dd": 1.1,
    "\u05be": 0.6, "\u05c0": 0.3, "\u05c3": 0.3, ":": 0.3,
}
SPACE_WIDTH = 0.5


def _word_width(word):
    w = 0.0
    for ch in word:
        if unicodedata.category(ch) == "Mn":
            continue
        w += _HEB_W.get(ch, 0.85)
    return w


def _line_widths(words):
    ws = [_word_width(w) for w in words]
    return ws, sum(ws) + SPACE_WIDTH * max(0, len(words) - 1)


# ---------------------------------------------------------------------------
# Page and verse lookup
# ---------------------------------------------------------------------------


def find_page_for_verse(book, ch, v):
    """Scan cam1753-line-breaks/ to find the page containing
    <book> <ch>:<v>.  Returns page_id or None."""
    target = f"{book} {ch}:{v}"
    for path in sorted(LB_DIR.glob("*.json")):
        stream = json.loads(path.read_text("utf-8"))
        # Check if this page has the verse with actual words inside
        # line-start/line-end regions (not just empty verse markers).
        in_verse = False
        in_lb = False
        has_words_in_lb = False
        for item in stream:
            if isinstance(item, dict):
                if "line-start" in item:
                    in_lb = True
                if "line-end" in item:
                    in_lb = False
                vs = item.get("verse-start") or item.get("verse-fragment-start")
                ve = item.get("verse-end") or item.get("verse-fragment-end")
                if vs == target:
                    in_verse = True
                if ve == target:
                    in_verse = False
            elif isinstance(item, str) and in_verse and in_lb:
                has_words_in_lb = True
                break
        if has_words_in_lb:
            return path.stem
    return None


def find_word_in_linebreaks(page_id, book, ch, v, consensus):
    """Find a word in cam1753 line-break data.

    Returns (col, line_num, word_index_in_line, line_words).
    """
    lb_path = LB_DIR / f"{page_id}.json"
    stream = json.loads(lb_path.read_text("utf-8"))

    verse_label = f"{book} {ch}:{v}"
    in_verse = False
    cur_col = cur_line = None
    consensus_stripped = strip_heb(consensus)
    consensus_has_maqaf = MAQAF in consensus

    target_col = target_line = None
    match_count = 0
    recent_words = []

    for item in stream:
        if isinstance(item, dict):
            if item.get("verse-start") == verse_label or \
               item.get("verse-fragment-start") == verse_label:
                in_verse = True
                recent_words = []
                continue
            if item.get("verse-end") == verse_label or \
               item.get("verse-fragment-end") == verse_label:
                in_verse = False
                continue
            if "line-start" in item:
                cur_col = item["line-start"]["col"]
                cur_line = item["line-start"]["line-num"]
                continue
        elif isinstance(item, str) and in_verse:
            item_stripped = strip_heb(item)
            matched = (
                item == consensus
                or item_stripped == consensus_stripped
                or (consensus.endswith(MAQAF)
                    and item_stripped == strip_heb(consensus[:-1]))
            )
            if matched:
                match_count += 1
                if match_count == 1:
                    target_col, target_line = cur_col, cur_line
                continue
            if consensus_has_maqaf:
                recent_words.append(item)
                joined = "".join(recent_words)
                if strip_heb(joined) == consensus_stripped or joined == consensus:
                    match_count += 1
                    if match_count == 1:
                        target_col, target_line = cur_col, cur_line
                    continue
                while recent_words and not consensus_stripped.startswith(
                    strip_heb("".join(recent_words))
                ):
                    recent_words.pop(0)

    if match_count > 1:
        raise ValueError(
            f"Ambiguous: {match_count} matches for {consensus!r} in "
            f"{verse_label} on page {page_id}"
        )
    if target_col is None:
        return None, None, None, []

    # Collect all words on the target line
    in_target = False
    line_words = []
    for item in stream:
        if isinstance(item, dict):
            if "line-start" in item:
                ls = item["line-start"]
                if ls["col"] == target_col and ls["line-num"] == target_line:
                    in_target = True
                    line_words = []
                continue
            if "line-end" in item and in_target:
                break
        elif isinstance(item, str) and in_target:
            line_words.append(item)

    # Find word index within the line
    target_idx = None
    for i, w in enumerate(line_words):
        if (w == consensus or strip_heb(w) == consensus_stripped
                or (consensus.endswith(MAQAF)
                    and strip_heb(w) == strip_heb(consensus[:-1]))):
            target_idx = i
            break
        if consensus_has_maqaf and w.endswith(MAQAF):
            joined = w
            for j in range(i + 1, len(line_words)):
                joined += line_words[j]
                if strip_heb(joined) == consensus_stripped or joined == consensus:
                    target_idx = i
                    break
                if not line_words[j].endswith(MAQAF):
                    break
            if target_idx is not None:
                break

    return target_col, target_line, target_idx, line_words


# ---------------------------------------------------------------------------
# Quad-based geometry
# ---------------------------------------------------------------------------


def get_line_bbox(page_id, col, line_num, buffer_lines=2):
    """Get pixel bounding box for a line using quad coordinates.

    Returns (crop_left, crop_top, crop_right, crop_bot,
             target_offset_from_crop_top, line_spacing_px).
    """
    qpath = QUAD_DIR / f"{page_id}.json"
    qdata = json.loads(qpath.read_text("utf-8"))
    img_w, img_h = qdata["image_size"]

    col_key = f"col{col}"
    px = qdata["columns"][col_key]["px"]
    tl, tr, bl, br = px["tl"], px["tr"], px["bl"], px["br"]

    # Line spacing: average height of column / 26 lines
    col_h = ((bl[1] + br[1]) - (tl[1] + tr[1])) / 2
    ls = col_h / LINES_PER_COL

    # Interpolate top-left/right of the target line
    frac = (line_num - 1) / LINES_PER_COL
    frac_bot = line_num / LINES_PER_COL
    line_top_l = tl[1] + (bl[1] - tl[1]) * frac
    line_top_r = tr[1] + (br[1] - tr[1]) * frac
    line_bot_l = tl[1] + (bl[1] - tl[1]) * frac_bot
    line_bot_r = tr[1] + (br[1] - tr[1]) * frac_bot
    line_top = min(line_top_l, line_top_r)
    line_bot = max(line_bot_l, line_bot_r)

    # Column x extents (with margin)
    col_left = min(tl[0], bl[0])
    col_right = max(tr[0], br[0])
    margin_x = int((col_right - col_left) * 0.05)

    crop_top = max(0, int(line_top - buffer_lines * ls))
    crop_bot = min(img_h, int(line_bot + buffer_lines * ls))
    crop_left = max(0, col_left - margin_x)
    crop_right = min(img_w, col_right + margin_x)

    target_offset = int(line_top - crop_top)
    return crop_left, crop_top, crop_right, crop_bot, target_offset, int(ls)


def load_page_image(page_id):
    """Load a cam1753 page image from the local cam1753-pages/ directory."""
    path = IMG_DIR / f"{page_id}.jpg"
    if not path.exists():
        print(f"  ERROR: image not found: {path}")
        sys.exit(1)
    return Image.open(path)


# ---------------------------------------------------------------------------
# Preview generation
# ---------------------------------------------------------------------------


def find_and_preview(word, book, cv):
    """Find *word* in *book* *cv* on cam1753 and generate a preview.

    Returns a dict of result metadata, or None on failure.
    """
    ch, v = (int(x) for x in cv.split(":"))

    print(f"\n=== {book} {cv}: {word} ===")

    page_id = find_page_for_verse(book, ch, v)
    if not page_id:
        print(f"  ERROR: Could not find page for {book} {cv}")
        return None
    print(f"  Page: {page_id}")

    col, line_num, word_idx, line_words = find_word_in_linebreaks(
        page_id, book, ch, v, word
    )
    if col is None:
        print(f"  ERROR: Could not find word in line-break data")
        return None
    print(f"  Location: col {col}, line {line_num}, word {word_idx + 1}")
    print(f"  Line: {' '.join(line_words)}")

    crop_left, crop_top, crop_right, crop_bot, target_offset, ls = get_line_bbox(
        page_id, col, line_num
    )

    img = load_page_image(page_id)
    print(f"  Image: {img.size[0]}x{img.size[1]}")

    crop = img.crop((crop_left, crop_top, crop_right, crop_bot)).convert("RGBA")

    highlight_top = target_offset
    highlight_bot = target_offset + ls

    # Estimate horizontal word position (RTL: word 0 is at right edge)
    word_ws, total_width = _line_widths(line_words)
    if total_width > 0:
        width_before = sum(word_ws[:word_idx]) + SPACE_WIDTH * word_idx
        width_target = word_ws[word_idx] if word_idx < len(word_ws) else 0
        frac_start = width_before / total_width
        frac_end = (width_before + width_target) / total_width
        buffer = 0.15
        frac_left = max(0, frac_start - buffer)
        frac_right = min(1, frac_end + buffer)
        highlight_right = int(crop.width * (1 - frac_left))
        highlight_left = int(crop.width * (1 - frac_right))
    else:
        highlight_left = 0
        highlight_right = crop.width

    # 2D fade overlay
    h, w = crop.height, crop.width
    fade_color = (200, 180, 60)
    max_alpha = 200

    vert_fade = np.zeros(h, dtype=np.float64)
    for y in range(h):
        if y < highlight_top:
            vert_fade[y] = ((highlight_top - y) / max(highlight_top, 1)) ** 0.6
        elif y > highlight_bot:
            vert_fade[y] = ((y - highlight_bot) / max(h - highlight_bot, 1)) ** 0.6

    horiz_fade = np.zeros(w, dtype=np.float64)
    for x in range(w):
        if x < highlight_left:
            horiz_fade[x] = ((highlight_left - x) / max(highlight_left, 1)) ** 0.6
        elif x > highlight_right:
            horiz_fade[x] = ((x - highlight_right) / max(w - highlight_right, 1)) ** 0.6

    combined = np.maximum(
        vert_fade[:, np.newaxis], horiz_fade[np.newaxis, :]
    )
    alpha_arr = (combined * max_alpha).clip(0, 255).astype(np.uint8)

    overlay_arr = np.zeros((h, w, 4), dtype=np.uint8)
    overlay_arr[:, :, 0] = fade_color[0]
    overlay_arr[:, :, 1] = fade_color[1]
    overlay_arr[:, :, 2] = fade_color[2]
    overlay_arr[:, :, 3] = alpha_arr
    yellow_overlay = Image.fromarray(overlay_arr, "RGBA")

    # Red position lines
    red_overlay = Image.new("RGBA", crop.size, (0, 0, 0, 0))
    draw = ImageDraw.Draw(red_overlay)
    half_ls = ls // 2
    box_top = max(0, highlight_top - half_ls)
    box_bot = min(h - 1, highlight_bot + half_ls)
    cx = (highlight_left + highlight_right) // 2
    half_w = max(cx - highlight_left, highlight_right - cx, 1)
    for x_pos in range(highlight_left, highlight_right + 1):
        dist = abs(x_pos - cx)
        a = max(0, int(255 * (1 - dist / half_w)))
        c = (255, 0, 0, a)
        draw.point((x_pos, box_top), fill=c)
        draw.point((x_pos, box_top + 1), fill=c)
        draw.point((x_pos, box_bot), fill=c)
        draw.point((x_pos, box_bot - 1), fill=c)
    tick = min(12, (box_bot - box_top) // 4)
    draw.line([(cx, box_top), (cx, box_top + tick)], fill=(255, 0, 0, 255), width=2)
    draw.line([(cx, box_bot - tick), (cx, box_bot)], fill=(255, 0, 0, 255), width=2)

    # Save 4 image variants
    label = f"{book}_{cv.replace(':', '_')}"
    OUT_DIR.mkdir(exist_ok=True)
    raw_path = OUT_DIR / f"preview_{label}_raw.png"
    crop.save(raw_path)
    crop_y = Image.alpha_composite(crop, yellow_overlay)
    (OUT_DIR / f"preview_{label}.png").parent.mkdir(exist_ok=True)
    crop_y.save(OUT_DIR / f"preview_{label}.png")
    crop_r = Image.alpha_composite(crop, red_overlay)
    crop_r.save(OUT_DIR / f"preview_{label}_red.png")
    crop_yr = Image.alpha_composite(crop_y, red_overlay)
    crop_yr.save(OUT_DIR / f"preview_{label}_yr.png")

    print(f"  Saved: 4 variants as preview_{label}_*.png ({crop.width}x{crop.height})")

    before = line_words[:word_idx]
    matched_word = line_words[word_idx] if word_idx < len(line_words) else word
    after = line_words[word_idx + 1:] if word_idx + 1 < len(line_words) else []
    print(f"  Context: {' '.join(before)} [{matched_word}] {' '.join(after)}")

    # Initial bounding box in relative (0–1) coords for the crop editor
    half_ls_box = ls // 2
    init_box_top = max(0, highlight_top - half_ls_box)
    init_box_bot = min(h - 1, highlight_bot + half_ls_box)

    return {
        "label": label,
        "book": book,
        "cv": cv,
        "word": word,
        "page": page_id,
        "col": col,
        "line_num": line_num,
        "word_idx": word_idx,
        "before": before,
        "matched_word": matched_word,
        "after": after,
        "crop_w": crop.width,
        "crop_h": crop.height,
        "box_left": round(highlight_left / crop.width, 4),
        "box_right": round(highlight_right / crop.width, 4),
        "box_top": round(init_box_top / crop.height, 4),
        "box_bot": round(init_box_bot / crop.height, 4),
    }


def generate_html(result):
    """Build the preview HTML with crop mode from a single result and open it."""
    r = result
    before_joined = join_maqaf(list(r["before"]))
    after_joined = join_maqaf(list(r["after"]))
    target_display = r["matched_word"]
    if before_joined and before_joined[-1].endswith(MAQAF):
        target_display = before_joined.pop() + target_display
    if target_display.endswith(MAQAF) and after_joined:
        target_display = target_display + after_joined.pop(0)
    before_html = " ".join(before_joined)
    after_html = " ".join(after_joined)

    html_path = OUT_DIR / "preview_word_crops.html"
    label = r["label"]
    verse_display = f"{r['book']} {r['cv']}"

    item_json = json.dumps({
        "label": r["label"],
        "book": r["book"],
        "cv": r["cv"],
        "word": r["word"],
        "page": r["page"],
        "col": r["col"],
        "lineNum": r["line_num"],
        "wordIdx": r["word_idx"],
        "cropW": r["crop_w"],
        "cropH": r["crop_h"],
        "box": {
            "left": r["box_left"],
            "top": r["box_top"],
            "right": r["box_right"],
            "bottom": r["box_bot"],
        },
    }, ensure_ascii=False)

    with open(html_path, "w", encoding="utf-8") as f:
        f.write(f"""<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Preview \u2014 {verse_display}: {r["word"]}</title>
<style>
body {{ background: #222; color: #eee; font-family: sans-serif; padding: 20px; }}
.preview h2 {{ margin-bottom: 5px; }}
.preview .meta {{ margin-top: 2px; color: #aaa; font-size: 14px; }}
.crop-box {{ display: inline-block; }}
.context {{ direction: rtl; unicode-bidi: embed; font-size: 22px; margin: 0; padding: 6px 0; text-align: center; border: 1px solid #555; border-bottom: none; background: #2a2a2a; }}
.context .before, .context .after {{ color: #888; }}
.context .target {{ color: #fff; background: #553; padding: 2px 4px; border-radius: 3px; }}

/* Image + SVG overlay */
.img-wrapper {{ position: relative; display: inline-block; line-height: 0; }}
.img-wrapper img {{ display: block; border: 1px solid #555; }}
.img-wrapper svg {{
  position: absolute; top: 0; left: 0;
  width: 100%; height: 100%; pointer-events: none;
}}
.ctrl-point {{
  pointer-events: all !important;
  cursor: grab;
}}
.ctrl-point:hover {{ fill-opacity: 1; }}
.ctrl-point.dragging {{ cursor: grabbing; }}

/* Toolbar */
#toolbar {{
  position: sticky; top: 0; z-index: 100;
  background: #333; padding: 8px 12px;
  border-bottom: 1px solid #555;
  display: flex; align-items: center; gap: 10px; flex-wrap: wrap;
}}
#toolbar button {{
  padding: 5px 12px; cursor: pointer; font-size: 13px;
  border: 1px solid #888; border-radius: 4px;
  background: #444; color: #eee;
}}
#toolbar button.active {{ background: #668; border-color: #aaf; }}
#status {{ font-size: 13px; color: #aaa; margin-left: 8px; }}
</style>
</head>
<body>

<div id="toolbar">
  <button id="toggle-yellow" onclick="toggleYellow()">Hide yellow fade</button>
  <button id="toggle-red" onclick="toggleRed()">Hide red position lines</button>
  <button id="crop-btn" onclick="toggleCropMode()">Crop mode</button>
  <button id="fine-btn" onclick="toggleFine()" style="display:none">Fine</button>
  <button id="reset-btn" onclick="resetBox()" style="display:none">Reset box</button>
  <button id="copy-url-btn" onclick="copyDataURL()" style="display:none">Copy crop as data URL</button>
  <button id="download-btn" onclick="downloadCrop()" style="display:none">Download crop PNG</button>
  <span id="status"></span>
</div>

<div class="preview">
<h2>{verse_display} \u2014 {r["word"]}</h2>
<p class="meta">Page {r["page"]}, col {r["col"]}, line {r["line_num"]}, word {r["word_idx"] + 1}</p>
<div class="crop-box">
<p class="context"><span class="before">{before_html}</span> <span class="target">{target_display}</span> <span class="after">{after_html}</span></p>
<div class="img-wrapper" id="wrap-0">
  <img id="main-img" class="crop-img"
       src="preview_{label}_yr.png"
       data-raw="preview_{label}_raw.png"
       data-y="preview_{label}.png"
       data-r="preview_{label}_red.png"
       data-yr="preview_{label}_yr.png">
  <svg id="svg-0" viewBox="0 0 1 1" preserveAspectRatio="none"></svg>
</div>
</div>
</div>

<script>
// ── Data ──────────────────────────────────────
const ITEM = {item_json};

// ── Image toggle state ────────────────────────
let showYellow = true;
let showRed = true;

function pickSrc(img) {{
  const key = (showYellow ? 'y' : '') + (showRed ? 'r' : '');
  img.src = img.dataset[key || 'raw'];
}}
function toggleYellow() {{
  showYellow = !showYellow;
  document.getElementById('toggle-yellow').textContent =
    showYellow ? 'Hide yellow fade' : 'Show yellow fade';
  document.querySelectorAll('.crop-img').forEach(pickSrc);
}}
function toggleRed() {{
  showRed = !showRed;
  document.getElementById('toggle-red').textContent =
    showRed ? 'Hide red position lines' : 'Show red position lines';
  document.querySelectorAll('.crop-img').forEach(pickSrc);
}}

// ── Crop mode state ───────────────────────────
let cropMode = false;
let fineMode = true;
const FINE_SCALE = 0.2;

const box = {{
  left:   ITEM.box.left,
  top:    ITEM.box.top,
  right:  ITEM.box.right,
  bottom: ITEM.box.bottom,
}};
const initBox = JSON.parse(JSON.stringify(box));

let lastSide = 'right';
let dragSide = null;
let dragTarget = null;
let dragStartMouse = null;
let dragStartBox = null;

function toggleCropMode() {{
  cropMode = !cropMode;
  const btn = document.getElementById('crop-btn');
  btn.classList.toggle('active', cropMode);
  btn.textContent = cropMode ? 'Exit crop mode' : 'Crop mode';

  // Show/hide crop-only buttons
  const cropBtns = ['fine-btn', 'reset-btn', 'copy-url-btn', 'download-btn'];
  cropBtns.forEach(id => {{
    document.getElementById(id).style.display = cropMode ? '' : 'none';
  }});

  // Show/hide preview toggle buttons
  const previewBtns = ['toggle-yellow', 'toggle-red'];
  previewBtns.forEach(id => {{
    document.getElementById(id).style.display = cropMode ? 'none' : '';
  }});

  if (cropMode) {{
    // Switch to raw image (no fade) to see the underlying image clearly
    const img = document.getElementById('main-img');
    img.src = img.dataset.raw;
    fineMode = true;
    document.getElementById('fine-btn').classList.add('active');
    drawBox();
    updateStatus();
  }} else {{
    clearBox();
    pickSrc(document.getElementById('main-img'));
    document.getElementById('status').textContent = '';
  }}
}}

function toggleFine() {{
  fineMode = !fineMode;
  document.getElementById('fine-btn').classList.toggle('active', fineMode);
  updateStatus();
}}

// ── SVG box drawing ───────────────────────────

function drawBox() {{
  const svg = document.getElementById('svg-0');
  const bw = box.right - box.left;
  const bh = box.bottom - box.top;
  const color = '#ff4040';
  const sw = 0.004;
  const hr = 0.011;

  let parts = [];

  // Rectangle
  parts.push(
    '<rect x="' + box.left + '" y="' + box.top + '" ' +
    'width="' + bw + '" height="' + bh + '" ' +
    'fill="none" stroke="' + color + '" stroke-width="' + sw + '" />'
  );

  // 4 edge handles + center move handle
  const handles = [
    {{ s: 'left',   cx: box.left,                    cy: (box.top + box.bottom) / 2, cur: 'ew-resize' }},
    {{ s: 'right',  cx: box.right,                   cy: (box.top + box.bottom) / 2, cur: 'ew-resize' }},
    {{ s: 'top',    cx: (box.left + box.right) / 2,  cy: box.top,                    cur: 'ns-resize' }},
    {{ s: 'bottom', cx: (box.left + box.right) / 2,  cy: box.bottom,                 cur: 'ns-resize' }},
    {{ s: 'move',   cx: (box.left + box.right) / 2,  cy: (box.top + box.bottom) / 2, cur: 'move' }},
  ];

  for (const hl of handles) {{
    const r = (hl.s === 'move') ? hr * 1.3 : hr;
    const fill = (hl.s === lastSide) ? '#ffff00'
               : (hl.s === 'move')   ? '#40a0ff'
               : color;
    parts.push(
      '<circle class="ctrl-point" ' +
      'cx="' + hl.cx + '" cy="' + hl.cy + '" r="' + r + '" ' +
      'fill="' + fill + '" fill-opacity="0.8" stroke="#fff" stroke-width="0.002" ' +
      'data-side="' + hl.s + '" ' +
      'style="cursor:' + hl.cur + '"/>'
    );
  }}

  svg.innerHTML = parts.join('\\n');
}}

function clearBox() {{
  document.getElementById('svg-0').innerHTML = '';
}}

// ── Drag handlers ─────────────────────────────

window.addEventListener('mousedown', (e) => {{
  if (!cropMode) return;
  const t = e.target;
  if (!t.classList || !t.classList.contains('ctrl-point')) return;
  dragSide = t.dataset.side;
  dragTarget = t;
  lastSide = dragSide;
  t.classList.add('dragging');

  const svg = document.getElementById('svg-0');
  const sr = svg.getBoundingClientRect();
  dragStartMouse = {{
    x: (e.clientX - sr.left) / sr.width,
    y: (e.clientY - sr.top)  / sr.height,
  }};
  dragStartBox = JSON.parse(JSON.stringify(box));
  e.preventDefault();
}});

window.addEventListener('mousemove', (e) => {{
  if (!dragSide) return;
  const svg = document.getElementById('svg-0');
  const sr = svg.getBoundingClientRect();
  let mx = (e.clientX - sr.left) / sr.width;
  let my = (e.clientY - sr.top)  / sr.height;

  if (fineMode) {{
    mx = dragStartMouse.x + (mx - dragStartMouse.x) * FINE_SCALE;
    my = dragStartMouse.y + (my - dragStartMouse.y) * FINE_SCALE;
  }}

  const b0 = dragStartBox;
  const MIN = 0.02;

  if (dragSide === 'move') {{
    const dx = mx - dragStartMouse.x;
    const dy = my - dragStartMouse.y;
    const bw = b0.right - b0.left;
    const bh = b0.bottom - b0.top;
    let nl = b0.left + dx;
    let nt = b0.top + dy;
    nl = Math.max(0, Math.min(1 - bw, nl));
    nt = Math.max(0, Math.min(1 - bh, nt));
    box.left = nl; box.right = nl + bw;
    box.top = nt; box.bottom = nt + bh;
  }} else if (dragSide === 'left') {{
    box.left = Math.max(0, Math.min(b0.right - MIN, mx));
  }} else if (dragSide === 'right') {{
    box.right = Math.min(1, Math.max(b0.left + MIN, mx));
  }} else if (dragSide === 'top') {{
    box.top = Math.max(0, Math.min(b0.bottom - MIN, my));
  }} else if (dragSide === 'bottom') {{
    box.bottom = Math.min(1, Math.max(b0.top + MIN, my));
  }}

  drawBox();
  updateStatus();
}});

window.addEventListener('mouseup', () => {{
  if (dragSide) {{
    if (dragTarget) dragTarget.classList.remove('dragging');
    dragSide = null;
    dragTarget = null;
    drawBox();
  }}
}});

// ── Keyboard ──────────────────────────────────

const ARROW_STEP = 0.002;

window.addEventListener('keydown', (e) => {{
  if (!cropMode) return;

  if (e.key === 'f' || e.key === 'F') {{ toggleFine(); return; }}

  if ('12345'.includes(e.key)) {{
    lastSide = ['left', 'right', 'top', 'bottom', 'move'][parseInt(e.key) - 1];
    drawBox();
    updateStatus();
    return;
  }}

  if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) return;
  e.preventDefault();

  const step = fineMode ? ARROW_STEP * FINE_SCALE : ARROW_STEP;

  if (lastSide === 'move') {{
    const bw = box.right - box.left;
    const bh = box.bottom - box.top;
    if (e.key === 'ArrowLeft')  box.left  = Math.max(0, box.left - step);
    if (e.key === 'ArrowRight') box.left  = Math.min(1 - bw, box.left + step);
    if (e.key === 'ArrowUp')    box.top   = Math.max(0, box.top - step);
    if (e.key === 'ArrowDown')  box.top   = Math.min(1 - bh, box.top + step);
    box.right = box.left + bw;
    box.bottom = box.top + bh;
  }} else if (lastSide === 'left') {{
    if (e.key === 'ArrowLeft')  box.left = Math.max(0, box.left - step);
    if (e.key === 'ArrowRight') box.left = Math.min(box.right - 0.02, box.left + step);
  }} else if (lastSide === 'right') {{
    if (e.key === 'ArrowLeft')  box.right = Math.max(box.left + 0.02, box.right - step);
    if (e.key === 'ArrowRight') box.right = Math.min(1, box.right + step);
  }} else if (lastSide === 'top') {{
    if (e.key === 'ArrowUp')   box.top = Math.max(0, box.top - step);
    if (e.key === 'ArrowDown') box.top = Math.min(box.bottom - 0.02, box.top + step);
  }} else if (lastSide === 'bottom') {{
    if (e.key === 'ArrowUp')   box.bottom = Math.max(box.top + 0.02, box.bottom - step);
    if (e.key === 'ArrowDown') box.bottom = Math.min(1, box.bottom + step);
  }}

  drawBox();
  updateStatus();
}});

// ── Status ────────────────────────────────────

function updateStatus() {{
  if (!cropMode) return;
  const fl = fineMode ? '  [FINE]' : '';
  const pxL = Math.round(box.left * ITEM.cropW);
  const pxT = Math.round(box.top * ITEM.cropH);
  const pxR = Math.round(box.right * ITEM.cropW);
  const pxB = Math.round(box.bottom * ITEM.cropH);
  document.getElementById('status').textContent =
    '(' + lastSide + ') ' +
    pxL + ',' + pxT + ' \u2013 ' + pxR + ',' + pxB +
    '  [' + (pxR - pxL) + '\u00d7' + (pxB - pxT) + 'px]' + fl;
}}

function resetBox() {{
  Object.assign(box, JSON.parse(JSON.stringify(initBox)));
  drawBox();
  updateStatus();
}}

// ── PNG metadata injection ────────────────────

// CRC-32 table for PNG chunk checksums
const crcTable = new Uint32Array(256);
for (let n = 0; n < 256; n++) {{
  let c = n;
  for (let k = 0; k < 8; k++) c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
  crcTable[n] = c;
}}
function crc32(buf) {{
  let c = 0xFFFFFFFF;
  for (let i = 0; i < buf.length; i++) c = crcTable[(c ^ buf[i]) & 0xFF] ^ (c >>> 8);
  return (c ^ 0xFFFFFFFF) >>> 0;
}}

function buildChunk(typeStr, dataBytes) {{
  const enc = new TextEncoder();
  const type = enc.encode(typeStr);
  const len = dataBytes.length;
  const chunk = new Uint8Array(12 + len);
  const view = new DataView(chunk.buffer);
  view.setUint32(0, len);
  chunk.set(type, 4);
  chunk.set(dataBytes, 8);
  const crcBuf = new Uint8Array(4 + len);
  crcBuf.set(type, 0);
  crcBuf.set(dataBytes, 4);
  view.setUint32(8 + len, crc32(crcBuf));
  return chunk;
}}

function makeTEXtChunk(keyword, latin1Text) {{
  // tEXt: keyword(Latin-1) + null + text(Latin-1)
  // Caller must ensure text is ASCII/Latin-1 safe
  const kwBytes = new Uint8Array([...keyword].map(c => c.charCodeAt(0)));
  const txtBytes = new Uint8Array([...latin1Text].map(c => c.charCodeAt(0) & 0xFF));
  const data = new Uint8Array(kwBytes.length + 1 + txtBytes.length);
  data.set(kwBytes, 0);
  data[kwBytes.length] = 0;
  data.set(txtBytes, kwBytes.length + 1);
  return buildChunk('tEXt', data);
}}

function makeITXtChunk(keyword, utf8Text) {{
  // iTXt: keyword + null + compression_flag(0) + compression_method(0)
  //       + language_tag + null + translated_keyword + null + text(UTF-8)
  const enc = new TextEncoder();
  const kwBytes = enc.encode(keyword);
  const txtBytes = enc.encode(utf8Text);
  // keyword\0 + 0 + 0 + \0 + \0 + text
  const data = new Uint8Array(kwBytes.length + 1 + 2 + 1 + 1 + txtBytes.length);
  data.set(kwBytes, 0);
  let pos = kwBytes.length;
  data[pos++] = 0;  // null after keyword
  data[pos++] = 0;  // compression flag
  data[pos++] = 0;  // compression method
  data[pos++] = 0;  // null after language tag (empty)
  data[pos++] = 0;  // null after translated keyword (empty)
  data.set(txtBytes, pos);
  return buildChunk('iTXt', data);
}}

function injectPngMetadata(pngArrayBuffer, textMeta, itxtMeta) {{
  // Insert tEXt + iTXt chunks right after the IHDR chunk (first chunk after
  // the 8-byte PNG signature). This avoids the "text after IDAT" warning.
  const src = new Uint8Array(pngArrayBuffer);
  const view = new DataView(pngArrayBuffer);

  // IHDR starts at offset 8; its length is at bytes 8..11
  const ihdrLen = view.getUint32(8);
  // IHDR chunk = 4 (length) + 4 (type) + ihdrLen (data) + 4 (CRC)
  const afterIHDR = 8 + 12 + ihdrLen;

  const chunks = [];
  for (const [key, val] of Object.entries(textMeta)) {{
    chunks.push(makeTEXtChunk(key, val));
  }}
  for (const [key, val] of Object.entries(itxtMeta)) {{
    chunks.push(makeITXtChunk(key, val));
  }}
  const extraLen = chunks.reduce((s, c) => s + c.length, 0);
  const out = new Uint8Array(src.length + extraLen);
  // Copy: signature + IHDR
  out.set(src.subarray(0, afterIHDR), 0);
  // Insert metadata chunks
  let offset = afterIHDR;
  for (const chunk of chunks) {{
    out.set(chunk, offset);
    offset += chunk.length;
  }}
  // Copy remaining chunks (IDAT..IEND)
  out.set(src.subarray(afterIHDR), offset);
  return out.buffer;
}}

// ── Crop export helpers ───────────────────────

function getCroppedBlob() {{
  return new Promise((resolve) => {{
    const rawImg = new Image();
    rawImg.onload = () => {{
      const pxL = Math.round(box.left * rawImg.naturalWidth);
      const pxT = Math.round(box.top * rawImg.naturalHeight);
      const pxR = Math.round(box.right * rawImg.naturalWidth);
      const pxB = Math.round(box.bottom * rawImg.naturalHeight);
      const cw = pxR - pxL;
      const ch = pxB - pxT;
      const canvas = document.createElement('canvas');
      canvas.width = cw;
      canvas.height = ch;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(rawImg, pxL, pxT, cw, ch, 0, 0, cw, ch);
      canvas.toBlob((blob) => resolve({{ blob, cw, ch }}), 'image/png');
    }};
    rawImg.src = document.getElementById('main-img').dataset.raw;
  }});
}}

function getCropMetadata() {{
  const comment = 'Page ' + ITEM.page + ', col ' + ITEM.col +
                  ', line ' + ITEM.lineNum + ', word ' + (ITEM.wordIdx + 1);
  const source = 'Cambridge University Library MS Add. 1753, page ' + ITEM.page;
  // tEXt: Latin-1 safe (no Hebrew, no em dash)
  const textMeta = {{
    'Title': ITEM.book + ' ' + ITEM.cv,
    'Comment': comment,
    'Source': source,
  }};
  // iTXt: full UTF-8 (Hebrew word, em dash)
  const itxtMeta = {{
    'Title': ITEM.book + ' ' + ITEM.cv + ' \u2014 ' + ITEM.word,
    'Comment': comment,
    'Source': source,
  }};
  return {{ textMeta, itxtMeta }};
}}

async function addMetadataToBlob(blob) {{
  const buf = await blob.arrayBuffer();
  const {{ textMeta, itxtMeta }} = getCropMetadata();
  const newBuf = injectPngMetadata(buf, textMeta, itxtMeta);
  return new Blob([newBuf], {{ type: 'image/png' }});
}}

async function copyDataURL() {{
  const {{ blob, cw, ch }} = await getCroppedBlob();
  const metaBlob = await addMetadataToBlob(blob);
  const reader = new FileReader();
  reader.onload = async () => {{
    await navigator.clipboard.writeText(reader.result);
    document.getElementById('status').textContent =
      'Copied data URL to clipboard (' + cw + '\u00d7' + ch + ', with metadata)';
    setTimeout(updateStatus, 2000);
  }};
  reader.readAsDataURL(metaBlob);
}}

async function downloadCrop() {{
  const {{ blob, cw, ch }} = await getCroppedBlob();
  const metaBlob = await addMetadataToBlob(blob);
  const a = document.createElement('a');
  a.download = 'crop_' + ITEM.label + '.png';
  a.href = URL.createObjectURL(metaBlob);
  a.click();
  URL.revokeObjectURL(a.href);
  document.getElementById('status').textContent =
    'Downloaded crop_' + ITEM.label + '.png (' + cw + '\u00d7' + ch + ', with metadata)';
  setTimeout(updateStatus, 2000);
}}
</script>
</body></html>
""")
    print(f"\nHTML: {html_path}")
    webbrowser.open(str(html_path))


def main():
    if len(sys.argv) != 4:
        print(
            "Usage: .venv\\Scripts\\python.exe"
            " main_find_word_in_cam1753_images.py <book> <c:v> <hebrew_word>"
        )
        print("Example: ... Job 7:1 \"\u05d5\u05b0\u05db\u05b4\u05d9\u05de\u05b5\u05d9\"")
        sys.exit(1)

    book = sys.argv[1]
    cv = sys.argv[2]
    word = sys.argv[3]
    if ":" not in cv:
        print(f"ERROR: verse must be in c:v format (e.g. 7:1), got: {cv}")
        sys.exit(1)

    result = find_and_preview(word, book, cv)
    if result:
        generate_html(result)
    else:
        sys.exit(1)


if __name__ == "__main__":
    main()
