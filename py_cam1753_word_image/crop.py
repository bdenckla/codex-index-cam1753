# Initially generated by GitHub Copilot.
"""Crop overlay utilities: fade overlay and horizontal word-position estimation."""

import numpy as np
from PIL import Image

from .hebrew_metrics import SPACE_WIDTH, line_widths


def estimate_word_position(line_words, word_idx, crop_w, buffer=0.15):
    """Estimate the horizontal pixel range of a word in a crop image.

    Hebrew is RTL, so word 0 is at the right edge.

    Parameters
    ----------
    line_words : list[str]
        All words on the line.
    word_idx : int
        0-based index of the target word.
    crop_w : int
        Width of the crop image in pixels.
    buffer : float
        Fractional buffer to add on each side of the estimate.

    Returns
    -------
    (highlight_left, highlight_right) : tuple[int, int]
        Pixel x-coordinates of the highlighted region within the crop.
    """
    word_ws, total_width = line_widths(line_words)
    if total_width <= 0:
        return 0, crop_w

    width_before = sum(word_ws[:word_idx]) + SPACE_WIDTH * word_idx
    width_target = word_ws[word_idx] if word_idx < len(word_ws) else 0
    frac_start = width_before / total_width
    frac_end = (width_before + width_target) / total_width
    frac_left = max(0.0, frac_start - buffer)
    frac_right = min(1.0, frac_end + buffer)
    # RTL: fractional position from right
    highlight_right = int(crop_w * (1 - frac_left))
    highlight_left = int(crop_w * (1 - frac_right))
    return highlight_left, highlight_right


def compute_fade_overlay(
    crop_w,
    crop_h,
    highlight_left,
    highlight_right,
    highlight_top,
    highlight_bot,
    fade_color=(200, 180, 60),
    max_alpha=200,
):
    """Create a 2-D fade overlay as a PIL RGBA Image.

    The overlay is transparent in the highlight region and fades to
    *fade_color* at the edges, guiding the eye toward the target word.

    Parameters
    ----------
    crop_w, crop_h : int
        Dimensions of the crop image.
    highlight_left, highlight_right : int
        Horizontal pixel range to keep clear.
    highlight_top, highlight_bot : int
        Vertical pixel range to keep clear.
    fade_color : tuple[int, int, int]
        RGB colour of the fade overlay.
    max_alpha : int
        Maximum alpha at the overlay edges.

    Returns
    -------
    PIL.Image (RGBA)
    """
    h, w = crop_h, crop_w

    vert_fade = np.zeros(h, dtype=np.float64)
    for y in range(h):
        if y < highlight_top:
            vert_fade[y] = ((highlight_top - y) / max(highlight_top, 1)) ** 0.6
        elif y > highlight_bot:
            vert_fade[y] = ((y - highlight_bot) / max(h - highlight_bot, 1)) ** 0.6

    horiz_fade = np.zeros(w, dtype=np.float64)
    for x in range(w):
        if x < highlight_left:
            horiz_fade[x] = ((highlight_left - x) / max(highlight_left, 1)) ** 0.6
        elif x > highlight_right:
            horiz_fade[x] = ((x - highlight_right) / max(w - highlight_right, 1)) ** 0.6

    combined = np.maximum(vert_fade[:, np.newaxis], horiz_fade[np.newaxis, :])
    alpha_arr = (combined * max_alpha).clip(0, 255).astype(np.uint8)

    overlay_arr = np.zeros((h, w, 4), dtype=np.uint8)
    overlay_arr[:, :, 0] = fade_color[0]
    overlay_arr[:, :, 1] = fade_color[1]
    overlay_arr[:, :, 2] = fade_color[2]
    overlay_arr[:, :, 3] = alpha_arr
    return Image.fromarray(overlay_arr, "RGBA")
