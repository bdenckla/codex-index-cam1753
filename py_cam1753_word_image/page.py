# Initially generated by GitHub Copilot.
"""Cambridge MS Add. 1753 page utilities: page lookup, quad geometry, image I/O."""

import json
import sys
from pathlib import Path

from PIL import Image

ROOT = Path(__file__).resolve().parent.parent
LB_DIR = ROOT / "cam1753-line-breaks"
QUAD_DIR = ROOT / "cam1753-col-quads"
IMG_DIR = ROOT / "cam1753-pages"

LINES_PER_COL = 26


def find_page_for_verse(book, ch, v):
    """Scan cam1753-line-breaks/ to find the page containing *book* *ch*:*v*.

    Returns the page_id (e.g. ``"0073A"``) or ``None``.
    """
    pages = find_pages_for_verse(book, ch, v)
    return pages[0] if pages else None


def find_pages_for_verse(book, ch, v):
    """Scan cam1753-line-breaks/ to find **all** pages containing *book* *ch*:*v*.

    Returns a list of page_id strings (e.g. ``["0073A", "0073B"]``),
    ordered by filename.  An empty list means the verse was not found.
    """
    target = f"{book} {ch}:{v}"
    result = []
    for path in sorted(LB_DIR.glob("*.json")):
        stream = json.loads(path.read_text("utf-8"))
        in_verse = False
        in_lb = False
        has_words_in_lb = False
        for item in stream:
            if isinstance(item, dict):
                if "line-start" in item:
                    in_lb = True
                if "line-end" in item:
                    in_lb = False
                vs = item.get("verse-start") or item.get("verse-fragment-start")
                ve = item.get("verse-end") or item.get("verse-fragment-end")
                if vs == target:
                    in_verse = True
                if ve == target:
                    in_verse = False
            elif isinstance(item, str) and in_verse and in_lb:
                has_words_in_lb = True
                break
        if has_words_in_lb:
            result.append(path.stem)
    return result


def get_line_bbox(page_id, col, line_num, buffer_lines=2, margin_factor=0.05):
    """Get pixel bounding box for a line using quad column coordinates.

    *margin_factor* controls horizontal padding as a fraction of column
    width (default 0.05 = 5%).  Use a larger value (e.g. 0.40) to
    capture masorah notes in the page margins.

    Returns ``(crop_left, crop_top, crop_right, crop_bot,
    target_offset_from_crop_top, line_spacing_px)``.
    """
    qpath = QUAD_DIR / f"{page_id}.json"
    qdata = json.loads(qpath.read_text("utf-8"))
    img_w, img_h = qdata["image_size"]

    col_key = f"col{col}"
    px = qdata["columns"][col_key]["px"]
    tl, tr, bl, br = px["tl"], px["tr"], px["bl"], px["br"]

    # Line spacing: average height of column / number of lines
    col_h = ((bl[1] + br[1]) - (tl[1] + tr[1])) / 2
    ls = col_h / LINES_PER_COL

    # Interpolate top/bottom of the target line
    frac = (line_num - 1) / LINES_PER_COL
    frac_bot = line_num / LINES_PER_COL
    line_top_l = tl[1] + (bl[1] - tl[1]) * frac
    line_top_r = tr[1] + (br[1] - tr[1]) * frac
    line_bot_l = tl[1] + (bl[1] - tl[1]) * frac_bot
    line_bot_r = tr[1] + (br[1] - tr[1]) * frac_bot
    line_top = min(line_top_l, line_top_r)
    line_bot = max(line_bot_l, line_bot_r)

    # Column x extents (with margin)
    col_left = min(tl[0], bl[0])
    col_right = max(tr[0], br[0])
    margin_x = int((col_right - col_left) * margin_factor)

    crop_top = max(0, int(line_top - buffer_lines * ls))
    crop_bot = min(img_h, int(line_bot + buffer_lines * ls))
    crop_left = max(0, col_left - margin_x)
    crop_right = min(img_w, col_right + margin_x)

    target_offset = int(line_top - crop_top)
    return crop_left, crop_top, crop_right, crop_bot, target_offset, int(ls)


def load_page_image(page_id):
    """Load a cam1753 page image from the local cam1753-pages/ directory.

    Returns a PIL Image. Exits with an error if the file is not found.
    """
    path = IMG_DIR / f"{page_id}.jpg"
    if not path.exists():
        print(f"  ERROR: image not found: {path}")
        sys.exit(1)
    return Image.open(path)
