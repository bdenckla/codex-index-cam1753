# Initially generated by GitHub Copilot.
"""
Generate an interactive HTML editor for adding/editing line-break
markers in cam1753 flat-stream JSON files.

Reads a flat-stream JSON from cam1753-line-breaks/<page>.json and
quad coordinates from cam1753-col-quads/<page>.json, then produces
a self-contained HTML file with:
  - Left panel: clickable ground-truth words (RTL) with existing
    line-break markers shown
  - Right panel: cam1753 page image cropped to the selected column

Click the last word of each line to toggle line-end markers.
"Export JSON" copies the updated flat-stream (with line-start/line-end
markers inserted) to the clipboard.

Requires a local HTTP server for images:
    python -m http.server 8119

Usage:
    .venv\\Scripts\\python.exe gen_cam1753_line_break_editor.py 0072B 1
    .venv\\Scripts\\python.exe gen_cam1753_line_break_editor.py 0072B 2
"""

import json
import sys
import webbrowser
from pathlib import Path

BASE = Path(__file__).resolve().parent
LB_DIR = BASE / "cam1753-line-breaks"
QUAD_DIR = BASE / "cam1753-col-quads"
IMG_DIR = BASE / "cam1753-pages"
OUT_DIR = BASE / ".novc"

LOCAL_IMG_BASE = "http://localhost:8119/cam1753-pages"


def _image_url(page_id):
    """Build local HTTP URL for a cam1753 page image."""
    return f"{LOCAL_IMG_BASE}/{page_id}.jpg"


def load_stream(page_id):
    """Load the flat-stream JSON for a page."""
    path = LB_DIR / f"{page_id}.json"
    if not path.exists():
        print(f"ERROR: {path} not found")
        sys.exit(1)
    return json.loads(path.read_text(encoding="utf-8"))


def load_quads(page_id):
    """Load quad coordinates for a page."""
    path = QUAD_DIR / f"{page_id}.json"
    if not path.exists():
        print(f"ERROR: {path} not found")
        sys.exit(1)
    return json.loads(path.read_text(encoding="utf-8"))


def _extract_words_and_markers(stream):
    """Extract word list and pre-existing line-end indices from a flat stream."""
    words = []
    line_ends = []
    page_start_idx = None
    current_verse = None
    word_idx = 0

    for item in stream:
        if isinstance(item, str):
            is_first = current_verse is not None and (
                len(words) == 0
                or words[-1].get("verse_label") != current_verse
                or words[-1].get("is_parashah")
            )
            words.append(
                {
                    "text": item,
                    "is_verse_start": is_first,
                    "verse_label": current_verse,
                    "is_parashah": False,
                }
            )
            word_idx += 1
        elif isinstance(item, dict):
            if "verse-start" in item:
                current_verse = item["verse-start"]
            elif "verse-fragment-start" in item:
                current_verse = item["verse-fragment-start"]
            elif "verse-end" in item:
                pass
            elif "verse-fragment-end" in item:
                pass
            elif "parashah" in item:
                words.append(
                    {
                        "text": item["parashah"],
                        "is_verse_start": False,
                        "verse_label": current_verse,
                        "is_parashah": True,
                        "parashah_value": item["parashah"],
                    }
                )
                word_idx += 1
            elif "line-start" in item:
                ls = item["line-start"]
                if ls["col"] == 1 and ls["line-num"] == 1:
                    page_start_idx = word_idx
            elif "line-end" in item:
                if word_idx > 0:
                    line_ends.append(
                        (
                            word_idx - 1,
                            item["line-end"]["col"],
                            item["line-end"]["line-num"],
                        )
                    )

    return words, line_ends, page_start_idx


def generate_editor_html(page_id, col):
    """Generate the HTML editor file for a cam1753 page."""
    stream = load_stream(page_id)
    words, line_ends, page_start_idx = _extract_words_and_markers(stream)
    image_url = _image_url(page_id)
    quads = load_quads(page_id)

    # Extract quad rel coordinates for CSS crop computation
    quad_json = json.dumps(quads, ensure_ascii=False)

    # Build JS data
    js_words = []
    for w in words:
        entry = {
            "text": w["text"],
            "isVerseStart": w["is_verse_start"],
            "verseLabel": w["verse_label"] or "",
            "isParashah": w["is_parashah"],
        }
        js_words.append(entry)

    js_line_ends = []
    for widx, col_num, lnum in line_ends:
        js_line_ends.append({"idx": widx, "col": col_num, "lineNum": lnum})

    stream_no_lines = [
        item
        for item in stream
        if not (
            isinstance(item, dict) and ("line-start" in item or "line-end" in item)
        )
    ]

    words_json = json.dumps(js_words, ensure_ascii=False, indent=None)
    line_ends_json = json.dumps(js_line_ends, ensure_ascii=False)
    stream_json = json.dumps(stream_no_lines, ensure_ascii=False, indent=2)
    page_start_js = "null" if page_start_idx is None else str(page_start_idx)

    col_label = "1 (right)" if col == 1 else "2 (left)"

    html = _HTML_TEMPLATE.format(
        page_id=page_id,
        image_url=image_url,
        col_label=col_label,
        col_num=col,
        other_col=2 if col == 1 else 1,
        words_json=words_json,
        line_ends_json=line_ends_json,
        stream_json=stream_json,
        page_start_idx_js=page_start_js,
        quad_json=quad_json,
    )

    out_path = OUT_DIR / f"cam1753_lb_editor_{page_id}_col{col}.html"
    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(html, encoding="utf-8")
    print(f"Wrote {out_path}")
    return out_path


_HTML_TEMPLATE = """<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="UTF-8">
<title>Line Break Editor \u2014 cam1753 {page_id}</title>
<style>
* {{ box-sizing: border-box; margin: 0; padding: 0; }}
body {{ font-family: 'Segoe UI', sans-serif; background: #1e1e1e; color: #d4d4d4; }}
h1 {{ text-align: center; padding: 10px; font-size: 17px; background: #252526; border-bottom: 1px solid #444; direction: ltr; }}
h1 button {{
    padding: 4px 12px; margin: 0 4px; cursor: pointer;
    background: #0e639c; color: #fff; border: none; border-radius: 4px;
    font-size: 13px; vertical-align: middle;
}}
h1 button:hover {{ background: #1177bb; }}
#status {{
    display: inline-block; margin-left: 12px;
    font-size: 13px; color: #888;
}}
.container {{ display: flex; height: calc(100vh - 45px); }}
.col-words {{
    overflow-y: auto; padding: 16px; direction: rtl;
    font-size: 22px;
    font-family: 'SBL Hebrew', 'Ezra SIL', 'Times New Roman', serif;
}}
.divider {{
    width: 6px;
    cursor: col-resize;
    background: transparent;
    transition: background 0.15s;
    flex-shrink: 0;
}}
.divider:hover, .divider.active {{
    background: #0e639c;
}}
.col-image {{
    overflow: auto;
    padding: 8px; direction: ltr;
    position: relative;
}}
.col-image img {{
    display: block;
    cursor: crosshair;
    transition: clip-path 0.2s;
}}
.word {{
    display: inline-block;
    padding: 3px 5px;
    margin: 1px;
    cursor: pointer;
    border-radius: 3px;
    border: 1px solid transparent;
    user-select: none;
    transition: background 0.12s;
    line-height: 1.8;
}}
.word:hover {{ background: #333; }}
.word.line-end {{
    background: #264f2a;
    border-color: #4ec94e;
    border-left: 3px solid #4ec94e;
}}
.word.parashah {{
    color: #e07040;
    font-size: 16px;
    font-family: monospace;
    cursor: pointer;
}}
.word.lead-in {{
    opacity: 0.35;
    cursor: default;
}}
.word.page-start {{
    background: #3a2a5f;
    border-color: #9a7adf;
    border-right: 3px solid #9a7adf;
}}
.page-start-label {{
    display: inline-block;
    color: #9a7adf;
    font-size: 11px;
    font-family: monospace;
    direction: ltr;
    margin-left: 4px;
}}
.word.verse-start {{
    border-bottom: 2px solid #5a5a8a;
}}
.word.maqaf-end {{
    margin-left: 0; padding-left: 0;
}}
.word.after-maqaf {{
    margin-right: 0; padding-right: 0;
}}
.line-num {{
    display: inline-block;
    color: #888;
    font-size: 12px;
    font-family: monospace;
    min-width: 40px;
    text-align: center;
    direction: ltr;
    margin-left: 4px;
}}
.col-label {{
    display: inline-block;
    color: #cc0;
    font-size: 11px;
    font-family: monospace;
    direction: ltr;
    margin-left: 2px;
    vertical-align: super;
}}
.line-num {{
    cursor: pointer;
}}
.line-num:hover {{
    color: #e0e040;
    text-decoration: underline;
}}
.blank-line {{
    display: block;
    height: 20px;
    border: 1px dashed #666;
    border-radius: 3px;
    margin: 2px 0;
    background: #2a2a2a;
    cursor: pointer;
    text-align: center;
    color: #666;
    font-size: 11px;
    font-family: monospace;
    direction: ltr;
    line-height: 20px;
}}
.blank-line:hover {{
    border-color: #c44;
    color: #c44;
    background: #3a2020;
}}
#syncIndicator {{
    display: inline-block;
    margin-left: 8px;
    font-size: 12px;
    font-family: monospace;
    padding: 2px 8px;
    border-radius: 3px;
    vertical-align: middle;
}}
#syncIndicator.on {{
    background: #264f2a;
    color: #4ec94e;
}}
#syncIndicator.off {{
    background: #3a2a2a;
    color: #666;
}}
.sync-fade-top {{
    position: absolute;
    pointer-events: none;
    z-index: 10;
    display: none;
    left: 0;
    right: 0;
}}
.sync-fade-bottom {{
    position: absolute;
    pointer-events: none;
    z-index: 10;
    display: none;
    left: 0;
    right: 0;
}}

</style>
</head>
<body>

<h1>cam1753 Line Break Editor \u2014 {page_id} \u2014 Col <span id="colLabel">{col_label}</span>
    <button onclick="exportJSON()">Export</button>
    <button id="colBtn" onclick="toggleCol()">Go to col <span id="colBtnNum">{other_col}</span></button>
    <button id="cropBtn" onclick="toggleCropMode()">Full page</button>
    <span id="syncIndicator" class="on">sync: ON [s]</span>
    <span id="status"></span>
</h1>
<div class="container" id="container">
    <div class="col-words" id="wordsPanel"></div>
    <div class="divider" id="divider"></div>
    <div class="col-image" id="imagePanel">
        <div id="fadeTop" class="sync-fade-top"></div>
        <div id="fadeBottom" class="sync-fade-bottom"></div>
        <img id="pageImg" src="{image_url}" alt="cam1753 {page_id}">
    </div>
</div>

<script>
const PAGE_ID = "{page_id}";
const MAQAF = '\\u05BE';
const quadData = {quad_json};

let cropMode = 'col';  // 'col' (cropped to column) or 'full' (full page)
let syncMode = true;

const allWords = {words_json};
const preExistingLineEnds = {line_ends_json};
const baseStream = {stream_json};

// State: Map<wordIdx, {{col, lineNum}}>
let lineEndMap = new Map();

// Blank lines after a given line-end word index.
// Map<wordIdx, count> — how many blank lines follow this line-end.
let blankLinesAfter = new Map();

let pageStartIdx = {page_start_idx_js};

// Initialize from pre-existing line ends
preExistingLineEnds.forEach(le => {{
    lineEndMap.set(le.idx, {{col: le.col, lineNum: le.lineNum}});
}});

let currentColNum = {col_num};
function currentCol() {{
    return currentColNum;
}}

function getColQuad(colNum) {{
    const colKey = 'col' + colNum;
    return quadData.columns[colKey].rel;
}}

function applyImageCrop() {{
    const img = document.getElementById('pageImg');
    if (cropMode === 'full') {{
        img.style.clipPath = '';
        img.style.width = '100%';
        img.style.marginLeft = '0';
        img.style.marginTop = '0';
        return;
    }}

    // Crop to column quad with some padding
    const q = getColQuad(currentColNum);
    const pad = 0.03;  // 3% padding around the quad

    // Get bounding box of the quad
    const xs = [q.tl[0], q.tr[0], q.bl[0], q.br[0]];
    const ys = [q.tl[1], q.tr[1], q.bl[1], q.br[1]];
    const minX = Math.max(0, Math.min(...xs) - pad);
    const maxX = Math.min(1, Math.max(...xs) + pad);
    const minY = Math.max(0, Math.min(...ys) - pad);
    const maxY = Math.min(1, Math.max(...ys) + pad);

    // Use clip-path to crop, and scale/offset the image so the
    // cropped region fills the panel
    const cropW = maxX - minX;
    const cropH = maxY - minY;

    // Scale the image so the cropped region fills the panel width
    const scaleFactor = 1 / cropW;
    // CSS margin-top % is relative to container *width*, not height,
    // so we must multiply by the image aspect ratio (height/width).
    const imgAR = quadData.image_size[1] / quadData.image_size[0];
    img.style.width = (scaleFactor * 100) + '%';
    img.style.marginLeft = (-minX * scaleFactor * 100) + '%';
    img.style.marginTop = (-minY * scaleFactor * imgAR * 100) + '%';

    // Clip to the padded bounding box (in image coordinates)
    const pct = v => (v * 100).toFixed(2) + '%';
    img.style.clipPath = `polygon(${{pct(minX)}} ${{pct(minY)}}, ${{pct(maxX)}} ${{pct(minY)}}, ${{pct(maxX)}} ${{pct(maxY)}}, ${{pct(minX)}} ${{pct(maxY)}})`;
}}

function toggleCol() {{
    currentColNum = currentColNum === 1 ? 2 : 1;
    applyImageCrop();
    const labels = {{1: '1 (right)', 2: '2 (left)'}};
    document.getElementById('colLabel').textContent = labels[currentColNum];
    document.getElementById('colBtnNum').textContent = currentColNum === 1 ? 2 : 1;
    if (syncMode) {{
        applySyncScroll();
    }} else {{
        document.getElementById('imagePanel').scrollTop = 0;
    }}
}}

function toggleSyncMode() {{
    syncMode = !syncMode;
    const ind = document.getElementById('syncIndicator');
    ind.className = syncMode ? 'on' : 'off';
    ind.textContent = syncMode ? 'sync: ON [s]' : 'sync: off [s]';
    if (syncMode) {{
        applySyncScroll();
    }} else {{
        document.getElementById('fadeTop').style.display = 'none';
        document.getElementById('fadeBottom').style.display = 'none';
    }}
}}

function getNextLineNum(col) {{
    // Count line-ends for the given column (including blank lines)
    const colEnds = [...lineEndMap.values()].filter(v => v.col === col);
    if (colEnds.length === 0) return 1;
    const maxLine = Math.max(...colEnds.map(v => v.lineNum));
    // Add blank lines after the last line-end
    const lastEndIdx = [...lineEndMap.entries()]
        .filter(([_, v]) => v.col === col && v.lineNum === maxLine)
        .map(([k, _]) => k)[0];
    const blanksAfterLast = blankLinesAfter.get(lastEndIdx) || 0;
    return maxLine + blanksAfterLast + 1;
}}

function getLineYRange(col, lineNum) {{
    // Interpolate the Y range for a line within the column quad.
    // 26 lines span from top to bottom of the column.
    const q = getColQuad(col);
    const topY = (q.tl[1] + q.tr[1]) / 2;
    const botY = (q.bl[1] + q.br[1]) / 2;
    const lineH = (botY - topY) / 26;
    const y0 = topY + (lineNum - 1) * lineH;
    const y1 = topY + lineNum * lineH;
    return {{ y0, y1, topY, botY, lineH }};
}}

function applySyncScroll() {{
    if (!syncMode) return;
    const col = currentColNum;
    const nextLine = getNextLineNum(col);
    const fadeTop = document.getElementById('fadeTop');
    const fadeBot = document.getElementById('fadeBottom');

    if (nextLine > 26) {{
        // Column is done
        fadeTop.style.display = 'none';
        fadeBot.style.display = 'none';
        return;
    }}

    const {{ y0, y1, lineH }} = getLineYRange(col, nextLine);
    const img = document.getElementById('pageImg');
    const panel = document.getElementById('imagePanel');

    // Position the fade overlays around the target line.
    // Buffer of 0.25 line-heights above and below the line.
    requestAnimationFrame(() => {{
        const imgRect = img.getBoundingClientRect();
        const panelRect = panel.getBoundingClientRect();
        const imgNatH = img.naturalHeight || 3072;
        const imgNatW = img.naturalWidth || 2200;
        const imgAR = imgNatH / imgNatW;

        const imgDispW = imgRect.width;
        const imgDispH = imgDispW * imgAR;

        // Clear zone: line ± 0.25 line-height buffer
        const buf = lineH * 0.25;
        const clearTop = (y0 - buf) * imgDispH;
        const clearBot = (y1 + buf) * imgDispH;
        const lineHpx = lineH * imgDispH;

        const imgTopInPanel = imgRect.top - panelRect.top + panel.scrollTop;

        // Build a gradient that goes from transparent (at the clear-zone
        // edge) to full darkness in ~1 line-height, matching the power-
        // curve fade from the Aleppo word finder: (dist/range)^0.6
        // Approximate with 4 stops over 1 line-height.
        const dk = 'rgba(0,0,0,0.6)';
        const makeGrad = (dir, totalH) => {{
            if (totalH <= 0) return dk;
            // stops at 0%, 25%, 50%, 75%, 100% of 1 lineH from the
            // transparent edge, expressed as px from that edge
            const s = Math.min(lineHpx, totalH);  // fade span
            const p = (frac) => {{
                const alpha = Math.pow(frac, 0.6) * 0.6;
                return `rgba(0,0,0,${{alpha.toFixed(3)}})`;
            }};
            // Stops from opaque end to transparent end
            const pcts = [
                `${{dk}} 0px`,
                `${{dk}} ${{Math.max(0, totalH - s).toFixed(1)}}px`,
                `${{p(0.75)}} ${{(totalH - s * 0.25).toFixed(1)}}px`,
                `${{p(0.5)}} ${{(totalH - s * 0.5).toFixed(1)}}px`,  // was unused
                `rgba(0,0,0,0) ${{totalH.toFixed(1)}}px`,
            ];
            return `linear-gradient(${{dir}}, ${{pcts.join(', ')}})`;
        }};

        // Top fade: from image top to clear zone top
        const topH = Math.max(0, clearTop);
        fadeTop.style.display = 'block';
        fadeTop.style.top = imgTopInPanel + 'px';
        fadeTop.style.height = topH + 'px';
        fadeTop.style.background = makeGrad('to bottom', topH);

        // Bottom fade: from clear zone bottom to image bottom
        const botH = Math.max(0, imgDispH - clearBot);
        fadeBot.style.display = 'block';
        fadeBot.style.top = (imgTopInPanel + clearBot) + 'px';
        fadeBot.style.height = botH + 'px';
        fadeBot.style.background = makeGrad('to top', botH);

        // Scroll panel to center the clear zone
        const clearMid = imgTopInPanel + (clearTop + clearBot) / 2;
        const panelH = panelRect.height;
        const targetScroll = clearMid - panelH / 2;
        panel.scrollTop = Math.max(0, targetScroll);

        // Scroll the words panel to center on the next line's start word
        syncWordsPanel(col);
    }});
}}

function syncWordsPanel(col) {{
    // Find the first word of the next unmarked line: it's the word
    // right after the last line-end in flat order for this column.
    const sorted = [...lineEndMap.entries()]
        .filter(([_, v]) => v.col === col)
        .sort((a, b) => a[0] - b[0]);
    let targetIdx;
    if (sorted.length === 0) {{
        // No line-ends yet — target is the first word (or pageStartIdx)
        targetIdx = pageStartIdx !== null ? pageStartIdx : 0;
    }} else {{
        const lastEndIdx = sorted[sorted.length - 1][0];
        targetIdx = lastEndIdx + 1;
    }}
    const el = document.querySelector(`.word[data-idx="${{targetIdx}}"]`);
    if (!el) return;
    const wp = document.getElementById('wordsPanel');
    const wpH = wp.clientHeight;
    // Scroll so the target word is vertically centered
    wp.scrollTop = el.offsetTop - wpH / 2;
}}

function toggleCropMode() {{
    cropMode = cropMode === 'col' ? 'full' : 'col';
    applyImageCrop();
    document.getElementById('cropBtn').textContent =
        cropMode === 'col' ? 'Full page' : 'Crop to col';
}}

function recalcLineNums() {{
    // Sort all line-ends by word index (flat order).
    // First 26 (accounting for blank lines) → col 1, rest → col 2.
    const sorted = [...lineEndMap.entries()].sort((a, b) => a[0] - b[0]);
    let flatLine = 1;  // 1-based flat line counter across both columns
    sorted.forEach(([idx, _]) => {{
        const col = flatLine <= 26 ? 1 : 2;
        const lineNum = flatLine <= 26 ? flatLine : flatLine - 26;
        const entry = lineEndMap.get(idx);
        entry.col = col;
        entry.lineNum = lineNum;
        flatLine++;
        // Account for blank lines after this line-end
        const blanks = blankLinesAfter.get(idx) || 0;
        flatLine += blanks;
    }});
}}

function render() {{
    const panel = document.getElementById('wordsPanel');
    panel.innerHTML = '';

    const isLeadIn = (idx) => pageStartIdx !== null && idx < pageStartIdx;

    const PARASHAH_DISPLAY = {{
        'spi-pe2': '{{\u05e4\u05e4}}',
        'spi-pe1': '{{\u05e4}}',
        'spi-sm1': '{{\u05e1}}',
    }};

    allWords.forEach((entry, idx) => {{
        const span = document.createElement('span');
        span.className = 'word';
        span.textContent = entry.isParashah
            ? (PARASHAH_DISPLAY[entry.text] || entry.text)
            : entry.text;
        span.dataset.idx = idx;

        const endsMaqaf = entry.text.endsWith(MAQAF);
        const prevEndsMaqaf = idx > 0 && allWords[idx - 1].text.endsWith(MAQAF);
        if (endsMaqaf) span.classList.add('maqaf-end');
        if (prevEndsMaqaf) span.classList.add('after-maqaf');

        if (isLeadIn(idx)) {{
            span.classList.add('lead-in');
        }} else if (entry.isParashah) {{
            span.classList.add('parashah');
            span.addEventListener('click', () => toggleLineEnd(idx));
        }} else {{
            if (entry.isVerseStart) {{
                span.classList.add('verse-start');
                span.title = entry.verseLabel;
            }}
            span.addEventListener('click', () => toggleLineEnd(idx));
        }}

        if (pageStartIdx === idx) {{
            span.classList.add('page-start');
        }}

        span.addEventListener('contextmenu', (e) => {{
            e.preventDefault();
            togglePageStart(idx);
        }});

        const leInfo = lineEndMap.get(idx);
        if (leInfo && !isLeadIn(idx)) {{
            span.classList.add('line-end');
            span.title = `Col ${{leInfo.col}}, Line ${{leInfo.lineNum}}`;
        }}

        panel.appendChild(span);

        if (pageStartIdx === idx) {{
            const lbl = document.createElement('span');
            lbl.className = 'page-start-label';
            lbl.textContent = '\\u25c0 page start';
            panel.appendChild(lbl);
        }}

        if (leInfo && !isLeadIn(idx)) {{
            const colLbl = document.createElement('span');
            colLbl.className = 'col-label';
            colLbl.textContent = `c${{leInfo.col}}`;

            const ln = document.createElement('span');
            ln.className = 'line-num';
            ln.textContent = leInfo.lineNum;
            ln.title = 'Click to add blank line after this line';
            ln.addEventListener('click', () => addBlankLine(idx));

            panel.appendChild(colLbl);
            panel.appendChild(ln);
            panel.appendChild(document.createElement('br'));

            // Render blank-line placeholders after this line-end
            const blanks = blankLinesAfter.get(idx) || 0;
            for (let b = 0; b < blanks; b++) {{
                const blankDiv = document.createElement('div');
                blankDiv.className = 'blank-line';
                const blankLineNum = leInfo.lineNum + 1 + b;
                blankDiv.textContent = `\u2014 blank line ${{blankLineNum}} (c${{leInfo.col}}) \u2014 click to remove`;
                blankDiv.addEventListener('click', () => {{
                    removeBlankLine(idx);
                }});
                panel.appendChild(blankDiv);
            }}
        }}
    }});

    updateStatus();
}}

function toggleLineEnd(idx) {{
    if (lineEndMap.has(idx)) {{
        blankLinesAfter.delete(idx);  // remove any blank lines too
        lineEndMap.delete(idx);
    }} else {{
        // Col and lineNum will be assigned by recalcLineNums
        lineEndMap.set(idx, {{col: 0, lineNum: 0}});
    }}
    recalcLineNums();
    render();

    // Auto-switch to col 2 when col 1 has 26 lines filled
    if (currentColNum === 1) {{
        const col1Count = [...lineEndMap.values()].filter(v => v.col === 1).length;
        const col1Blanks = [...lineEndMap.entries()]
            .filter(([_, v]) => v.col === 1)
            .reduce((sum, [k, _]) => sum + (blankLinesAfter.get(k) || 0), 0);
        if (col1Count + col1Blanks >= 26) {{
            toggleCol();
            return;  // toggleCol calls applySyncScroll
        }}
    }}
    applySyncScroll();
}}

function addBlankLine(wordIdx) {{
    // Add a blank line after the line ending at wordIdx
    const count = blankLinesAfter.get(wordIdx) || 0;
    blankLinesAfter.set(wordIdx, count + 1);
    recalcLineNums();
    render();
}}

function removeBlankLine(wordIdx) {{
    const count = blankLinesAfter.get(wordIdx) || 0;
    if (count <= 1) {{
        blankLinesAfter.delete(wordIdx);
    }} else {{
        blankLinesAfter.set(wordIdx, count - 1);
    }}
    recalcLineNums();
    render();
}}

function togglePageStart(idx) {{
    if (pageStartIdx === idx) {{
        pageStartIdx = null;
    }} else {{
        pageStartIdx = idx;
        for (const [k, _] of lineEndMap) {{
            if (k < idx) lineEndMap.delete(k);
        }}
        recalcLineNums();
    }}
    render();
}}

function updateStatus() {{
    const counts = {{}};
    lineEndMap.forEach(info => {{
        counts[info.col] = (counts[info.col] || 0) + 1;
    }});
    const parts = Object.entries(counts)
        .sort((a, b) => a[0] - b[0])
        .map(([c, n]) => `Col ${{c}}: ${{n}} lines`);
    const totalBlanks = [...blankLinesAfter.values()].reduce((a, b) => a + b, 0);
    const blankInfo = totalBlanks > 0 ? ` | ${{totalBlanks}} blank` : '';
    const psInfo = pageStartIdx !== null ? `Page start: word ${{pageStartIdx}}` : 'No page start set';
    document.getElementById('status').textContent =
        psInfo + (parts.length ? ' | ' + parts.join(' | ') : '') + blankInfo;
}}

function buildExportStream() {{
    const sorted = [...lineEndMap.entries()].sort((a, b) => a[0] - b[0]);
    const endSet = new Map();
    sorted.forEach(([idx, info]) => endSet.set(idx, info));

    const byCols = {{}};
    sorted.forEach(([idx, info]) => {{
        if (!byCols[info.col]) byCols[info.col] = [];
        byCols[info.col].push(idx);
    }});

    const startSet = new Map();
    for (const col in byCols) {{
        const ends = byCols[col];
        for (let i = 0; i < ends.length; i++) {{
            let startIdx;
            if (i === 0) {{
                if (parseInt(col) === 1 && pageStartIdx !== null) {{
                    startIdx = pageStartIdx;
                }} else {{
                    const allEndsBefore = sorted.filter(([eidx, _]) => eidx < ends[i]);
                    if (allEndsBefore.length > 0) {{
                        startIdx = allEndsBefore[allEndsBefore.length - 1][0] + 1;
                    }} else {{
                        startIdx = pageStartIdx !== null ? pageStartIdx : 0;
                    }}
                }}
            }} else {{
                startIdx = ends[i - 1] + 1;
            }}
            const lineNum = lineEndMap.get(ends[i]).lineNum;
            startSet.set(startIdx, {{col: parseInt(col), lineNum: lineNum}});
        }}
    }}

    const result = [];
    let wordIdx = 0;

    for (const item of baseStream) {{
        if (typeof item === 'string' || (typeof item === 'object' && item !== null && 'parashah' in item)) {{
            if (startSet.has(wordIdx)) {{
                const info = startSet.get(wordIdx);
                result.push({{"line-start": {{"col": info.col, "line-num": info.lineNum}}}});
            }}
            result.push(item);
            if (endSet.has(wordIdx)) {{
                const info = endSet.get(wordIdx);
                result.push({{"line-end": {{"col": info.col, "line-num": info.lineNum}}}});
                // Insert blank lines after this line-end
                const blanks = blankLinesAfter.get(wordIdx) || 0;
                for (let b = 0; b < blanks; b++) {{
                    const blankNum = info.lineNum + 1 + b;
                    result.push({{"blank-line": {{"col": info.col, "line-num": blankNum}}}});
                }}
            }}
            wordIdx++;
        }} else {{
            result.push(item);
        }}
    }}

    return trimPageBoundaryContent(result);
}}

function trimPageBoundaryContent(stream) {{
    let firstLineStart = -1;
    let lastLineEnd = -1;
    for (let i = 0; i < stream.length; i++) {{
        const item = stream[i];
        if (typeof item === 'object' && item !== null) {{
            if ('line-start' in item && firstLineStart === -1) firstLineStart = i;
            if ('line-end' in item) lastLineEnd = i;
        }}
    }}
    if (firstLineStart === -1 || lastLineEnd === -1) return stream;

    let hasPreWords = false;
    for (let i = 0; i < firstLineStart; i++) {{
        if (typeof stream[i] === 'string') {{ hasPreWords = true; break; }}
    }}
    if (hasPreWords) {{
        const kept = [];
        let lastVsIdx = -1;
        for (let i = 0; i < firstLineStart; i++) {{
            const item = stream[i];
            if (typeof item === 'object' && item !== null && 'verse-start' in item) {{
                lastVsIdx = kept.length;
                kept.push(item);
            }} else if (typeof item === 'string') {{
                // skip pre-content word
            }} else {{
                kept.push(item);
            }}
        }}
        if (lastVsIdx !== -1) {{
            const vs = kept[lastVsIdx]['verse-start'];
            kept[lastVsIdx] = {{'verse-fragment-start': vs}};
        }}
        stream = [...kept, ...stream.slice(firstLineStart)];
    }}

    lastLineEnd = -1;
    for (let i = 0; i < stream.length; i++) {{
        if (typeof stream[i] === 'object' && stream[i] !== null && 'line-end' in stream[i]) {{
            lastLineEnd = i;
        }}
    }}
    let hasPostWords = false;
    for (let i = lastLineEnd + 1; i < stream.length; i++) {{
        if (typeof stream[i] === 'string') {{ hasPostWords = true; break; }}
    }}
    if (hasPostWords) {{
        const kept = [];
        let firstVeIdx = -1;
        for (let i = lastLineEnd + 1; i < stream.length; i++) {{
            const item = stream[i];
            if (typeof item === 'object' && item !== null && 'verse-end' in item) {{
                if (firstVeIdx === -1) firstVeIdx = kept.length;
                kept.push(item);
            }} else if (typeof item === 'string') {{
                // skip post-content word
            }} else {{
                kept.push(item);
            }}
        }}
        if (firstVeIdx !== -1) {{
            const ve = kept[firstVeIdx]['verse-end'];
            kept[firstVeIdx] = {{'verse-fragment-end': ve}};
        }}
        stream = [...stream.slice(0, lastLineEnd + 1), ...kept];
    }}

    return stream;
}}

function exportJSON() {{
    const stream = buildExportStream();
    const jsonStr = JSON.stringify(stream, null, 2) + '\\n';
    navigator.clipboard.writeText(jsonStr).then(() => {{
        document.getElementById('status').textContent = 'Copied to clipboard!';
        setTimeout(updateStatus, 2000);
    }}).catch(err => {{
        const ta = document.createElement('textarea');
        ta.value = jsonStr;
        ta.style.cssText = 'position:fixed;top:10%;left:10%;width:80%;height:80%;z-index:999;font-size:12px;';
        document.body.appendChild(ta);
        ta.select();
        document.getElementById('status').textContent = 'Clipboard failed \\u2014 select all and copy manually';
    }});
}}

render();
applyImageCrop();
applySyncScroll();

// Auto-scroll: if editing col 2 and col 1 markers exist, scroll to
// show the last col 1 line-end
if (currentColNum === 2) {{
    const col1Ends = [...lineEndMap.entries()]
        .filter(([_, info]) => info.col === 1)
        .sort((a, b) => a[0] - b[0]);
    if (col1Ends.length > 0) {{
        const lastCol1Idx = col1Ends[col1Ends.length - 1][0];
        const el = document.querySelector(`.word[data-idx="${{lastCol1Idx}}"]`);
        if (el) {{
            const panel = document.getElementById('wordsPanel');
            panel.scrollTop = el.offsetTop - 40;
        }}
    }}
}}

// Keyboard shortcut: 's' to toggle sync mode
document.addEventListener('keydown', (e) => {{
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    if (e.key === 's' || e.key === 'S') {{
        e.preventDefault();
        toggleSyncMode();
    }}
}});

// --- Resizable divider ---
(function() {{
    const container = document.getElementById('container');
    const words = document.getElementById('wordsPanel');
    const divider = document.getElementById('divider');
    const image = document.getElementById('imagePanel');
    let wordsPct = 45;
    words.style.flex = '0 0 ' + wordsPct + '%';
    image.style.flex = '1 1 0%';
    let dragging = false;
    divider.addEventListener('mousedown', (e) => {{
        e.preventDefault();
        dragging = true;
        divider.classList.add('active');
    }});
    document.addEventListener('mousemove', (e) => {{
        if (!dragging) return;
        const rect = container.getBoundingClientRect();
        let pct = ((rect.right - e.clientX) / rect.width) * 100;
        pct = Math.max(10, Math.min(pct, 80));
        wordsPct = pct;
        words.style.flex = '0 0 ' + pct + '%';
    }});
    document.addEventListener('mouseup', () => {{
        if (dragging) {{
            dragging = false;
            divider.classList.remove('active');
        }}
    }});
}})();
</script>
</body>
</html>
"""


def main():
    if len(sys.argv) < 3:
        print(
            "Usage: .venv\\Scripts\\python.exe gen_cam1753_line_break_editor.py"
            " <page_id> <col>"
        )
        print("  e.g. ... 0072B 1")
        print("  col 1 = right column, col 2 = left column")
        sys.exit(1)
    page_id = sys.argv[1]
    col = int(sys.argv[2])
    out_path = generate_editor_html(page_id, col)
    webbrowser.open(str(out_path))


if __name__ == "__main__":
    main()
