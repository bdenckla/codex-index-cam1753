# Initially generated by GitHub Copilot.
"""
Preview a word on a Cambridge MS Add. 1753 page image.

Given a Hebrew word and a verse reference (e.g. "Job 7:1"), this script:
1. Scans cam1753-line-breaks/*.json to find which page contains the verse
2. Locates the word within the line-break data (page, col, line-num)
3. Gets pixel coordinates from quad data in cam1753-col-quads/
4. Loads the local page image from cam1753-pages/
5. Crops a generous region around the target line with a 2D fade overlay
6. Generates an HTML preview page in .novc/ and opens it

Usage:
    .venv\\Scripts\\python.exe main_find_word_in_cam1753_images.py <book> <c:v> <hebrew_word>

Example:
    .venv\\Scripts\\python.exe main_find_word_in_cam1753_images.py Job 7:1 "וְכִימֵ֖֗י"
"""

import json
import sys
import webbrowser
from pathlib import Path

from PIL import Image, ImageDraw

from py_cam1753_word_image.crop import compute_fade_overlay, estimate_word_position
from py_cam1753_word_image.hebrew_metrics import SPACE_WIDTH, join_maqaf
from py_cam1753_word_image.linebreak_search import (
    find_word_in_linebreaks as _find_word_in_linebreaks,
)
from py_cam1753_word_image.page import (
    LB_DIR,
    find_page_for_verse,
    get_line_bbox,
    load_page_image,
)

ROOT = Path(__file__).resolve().parent
OUT_DIR = ROOT / ".novc"
SERVER_PORT = 8753  # assumed to be running: python -m http.server 8753 -d .novc

MAQAF = "\u05be"


# ---------------------------------------------------------------------------
# Preview generation
# ---------------------------------------------------------------------------


def find_and_preview(word, book, cv):
    """Find *word* in *book* *cv* on cam1753 and generate a preview.

    Returns a dict of result metadata, or None on failure.
    """
    ch, v = (int(x) for x in cv.split(":"))

    print(f"\n=== {book} {cv}: {word} ===")

    page_id = find_page_for_verse(book, ch, v)
    if not page_id:
        print(f"  ERROR: Could not find page for {book} {cv}")
        return None
    print(f"  Page: {page_id}")

    col, line_num, word_idx, line_words = _find_word_in_linebreaks(
        LB_DIR, page_id, book, ch, v, word
    )
    if col is None:
        print(f"  ERROR: Could not find word in line-break data")
        return None
    print(f"  Location: col {col}, line {line_num}, word {word_idx + 1}")
    print(f"  Line: {' '.join(line_words)}")

    crop_left, crop_top, crop_right, crop_bot, target_offset, ls = get_line_bbox(
        page_id, col, line_num
    )

    img = load_page_image(page_id)
    print(f"  Image: {img.size[0]}x{img.size[1]}")

    crop = img.crop((crop_left, crop_top, crop_right, crop_bot)).convert("RGBA")

    highlight_top = target_offset
    highlight_bot = target_offset + ls

    # Estimate horizontal word position
    highlight_left, highlight_right = estimate_word_position(
        line_words, word_idx, crop.width
    )

    # 2D fade overlay
    yellow_overlay = compute_fade_overlay(
        crop.width, crop.height,
        highlight_left, highlight_right,
        highlight_top, highlight_bot,
    )

    # Red position lines
    h, w = crop.height, crop.width
    red_overlay = Image.new("RGBA", crop.size, (0, 0, 0, 0))
    draw = ImageDraw.Draw(red_overlay)
    half_ls = ls // 2
    box_top = max(0, highlight_top - half_ls)
    box_bot = min(h - 1, highlight_bot + half_ls)
    cx = (highlight_left + highlight_right) // 2
    half_w = max(cx - highlight_left, highlight_right - cx, 1)
    for x_pos in range(highlight_left, highlight_right + 1):
        dist = abs(x_pos - cx)
        a = max(0, int(255 * (1 - dist / half_w)))
        c = (255, 0, 0, a)
        draw.point((x_pos, box_top), fill=c)
        draw.point((x_pos, box_top + 1), fill=c)
        draw.point((x_pos, box_bot), fill=c)
        draw.point((x_pos, box_bot - 1), fill=c)
    tick = min(12, (box_bot - box_top) // 4)
    draw.line([(cx, box_top), (cx, box_top + tick)], fill=(255, 0, 0, 255), width=2)
    draw.line([(cx, box_bot - tick), (cx, box_bot)], fill=(255, 0, 0, 255), width=2)

    # Save 4 image variants
    label = f"{book}_{cv.replace(':', '_')}"
    OUT_DIR.mkdir(exist_ok=True)
    raw_path = OUT_DIR / f"preview_{label}_raw.png"
    crop.save(raw_path)
    crop_y = Image.alpha_composite(crop, yellow_overlay)
    (OUT_DIR / f"preview_{label}.png").parent.mkdir(exist_ok=True)
    crop_y.save(OUT_DIR / f"preview_{label}.png")
    crop_r = Image.alpha_composite(crop, red_overlay)
    crop_r.save(OUT_DIR / f"preview_{label}_red.png")
    crop_yr = Image.alpha_composite(crop_y, red_overlay)
    crop_yr.save(OUT_DIR / f"preview_{label}_yr.png")

    print(f"  Saved: 4 variants as preview_{label}_*.png ({crop.width}x{crop.height})")

    before = line_words[:word_idx]
    matched_word = line_words[word_idx] if word_idx < len(line_words) else word
    after = line_words[word_idx + 1:] if word_idx + 1 < len(line_words) else []
    print(f"  Context: {' '.join(before)} [{matched_word}] {' '.join(after)}")

    # Initial bounding box in relative (0\u20131) coords for the crop editor
    half_ls_box = ls // 2
    init_box_top = max(0, highlight_top - half_ls_box)
    init_box_bot = min(h - 1, highlight_bot + half_ls_box)

    return {
        "label": label,
        "book": book,
        "cv": cv,
        "word": word,
        "page": page_id,
        "col": col,
        "line_num": line_num,
        "word_idx": word_idx,
        "before": before,
        "matched_word": matched_word,
        "after": after,
        "crop_w": crop.width,
        "crop_h": crop.height,
        "box_left": round(highlight_left / crop.width, 4),
        "box_right": round(highlight_right / crop.width, 4),
        "box_top": round(init_box_top / crop.height, 4),
        "box_bot": round(init_box_bot / crop.height, 4),
    }


def generate_html(result):
    """Build the preview HTML with crop mode from a single result and open it."""
    r = result
    before_joined = join_maqaf(list(r["before"]))
    after_joined = join_maqaf(list(r["after"]))
    target_display = r["matched_word"]
    if before_joined and before_joined[-1].endswith(MAQAF):
        target_display = before_joined.pop() + target_display
    if target_display.endswith(MAQAF) and after_joined:
        target_display = target_display + after_joined.pop(0)
    before_html = " ".join(before_joined)
    after_html = " ".join(after_joined)

    html_path = OUT_DIR / "preview_word_crops.html"
    label = r["label"]
    verse_display = f"{r['book']} {r['cv']}"

    item_json = json.dumps({
        "label": r["label"],
        "book": r["book"],
        "cv": r["cv"],
        "word": r["word"],
        "page": r["page"],
        "col": r["col"],
        "lineNum": r["line_num"],
        "wordIdx": r["word_idx"],
        "cropW": r["crop_w"],
        "cropH": r["crop_h"],
        "box": {
            "left": r["box_left"],
            "top": r["box_top"],
            "right": r["box_right"],
            "bottom": r["box_bot"],
        },
    }, ensure_ascii=False)

    with open(html_path, "w", encoding="utf-8") as f:
        f.write(f"""<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Preview \u2014 {verse_display}: {r["word"]}</title>
<style>
body {{ background: #222; color: #eee; font-family: sans-serif; padding: 20px; }}
.preview h2 {{ margin-bottom: 5px; }}
.preview .meta {{ margin-top: 2px; color: #aaa; font-size: 14px; }}
.crop-box {{ display: inline-block; }}
.context {{ direction: rtl; unicode-bidi: embed; font-size: 22px; margin: 0; padding: 6px 0; text-align: center; border: 1px solid #555; border-bottom: none; background: #2a2a2a; }}
.context .before, .context .after {{ color: #888; }}
.context .target {{ color: #fff; background: #553; padding: 2px 4px; border-radius: 3px; }}

/* Image + SVG overlay */
.img-wrapper {{ position: relative; display: inline-block; line-height: 0; }}
.img-wrapper img {{ display: block; border: 1px solid #555; }}
.img-wrapper svg {{
  position: absolute; top: 0; left: 0;
  width: 100%; height: 100%; pointer-events: none;
}}
.ctrl-point {{
  pointer-events: all !important;
  cursor: grab;
}}
.ctrl-point:hover {{ fill-opacity: 1; }}
.ctrl-point.dragging {{ cursor: grabbing; }}

/* Toolbar */
#toolbar {{
  position: sticky; top: 0; z-index: 100;
  background: #333; padding: 8px 12px;
  border-bottom: 1px solid #555;
  display: flex; align-items: center; gap: 10px; flex-wrap: wrap;
}}
#toolbar button {{
  padding: 5px 12px; cursor: pointer; font-size: 13px;
  border: 1px solid #888; border-radius: 4px;
  background: #444; color: #eee;
}}
#toolbar button.active {{ background: #668; border-color: #aaf; }}
#status {{ font-size: 13px; color: #aaa; margin-left: 8px; }}
</style>
</head>
<body>

<div id="toolbar">
  <button id="toggle-yellow" onclick="toggleYellow()">Hide yellow fade</button>
  <button id="toggle-red" onclick="toggleRed()">Hide red position lines</button>
  <button id="crop-btn" onclick="toggleCropMode()">Crop mode</button>
  <button id="fine-btn" onclick="toggleFine()" style="display:none">Fine</button>
  <button id="reset-btn" onclick="resetBox()" style="display:none">Reset box</button>
  <button id="copy-url-btn" onclick="copyDataURL()" style="display:none">Copy crop as data URL</button>
  <button id="download-btn" onclick="downloadCrop()" style="display:none">Download crop PNG</button>
  <span id="status"></span>
</div>

<div class="preview">
<h2>{verse_display} \u2014 {r["word"]}</h2>
<p class="meta">Page {r["page"]}, col {r["col"]}, line {r["line_num"]}, word {r["word_idx"] + 1}</p>
<div class="crop-box">
<p class="context"><span class="before">{before_html}</span> <span class="target">{target_display}</span> <span class="after">{after_html}</span></p>
<div class="img-wrapper" id="wrap-0">
  <img id="main-img" class="crop-img"
       src="preview_{label}_yr.png"
       data-raw="preview_{label}_raw.png"
       data-y="preview_{label}.png"
       data-r="preview_{label}_red.png"
       data-yr="preview_{label}_yr.png">
  <svg id="svg-0" viewBox="0 0 1 1" preserveAspectRatio="none"></svg>
</div>
</div>
</div>

<script>
// ── Data ──────────────────────────────────────
const ITEM = {item_json};

// ── Image toggle state ────────────────────────
let showYellow = true;
let showRed = true;

function pickSrc(img) {{
  const key = (showYellow ? 'y' : '') + (showRed ? 'r' : '');
  img.src = img.dataset[key || 'raw'];
}}
function toggleYellow() {{
  showYellow = !showYellow;
  document.getElementById('toggle-yellow').textContent =
    showYellow ? 'Hide yellow fade' : 'Show yellow fade';
  document.querySelectorAll('.crop-img').forEach(pickSrc);
}}
function toggleRed() {{
  showRed = !showRed;
  document.getElementById('toggle-red').textContent =
    showRed ? 'Hide red position lines' : 'Show red position lines';
  document.querySelectorAll('.crop-img').forEach(pickSrc);
}}

// ── Crop mode state ───────────────────────────
let cropMode = false;
let fineMode = true;
const FINE_SCALE = 0.2;

const box = {{
  left:   ITEM.box.left,
  top:    ITEM.box.top,
  right:  ITEM.box.right,
  bottom: ITEM.box.bottom,
}};
const initBox = JSON.parse(JSON.stringify(box));

let lastSide = 'right';
let dragSide = null;
let dragTarget = null;
let dragStartMouse = null;
let dragStartBox = null;

function toggleCropMode() {{
  cropMode = !cropMode;
  const btn = document.getElementById('crop-btn');
  btn.classList.toggle('active', cropMode);
  btn.textContent = cropMode ? 'Exit crop mode' : 'Crop mode';

  // Show/hide crop-only buttons
  const cropBtns = ['fine-btn', 'reset-btn', 'copy-url-btn', 'download-btn'];
  cropBtns.forEach(id => {{
    document.getElementById(id).style.display = cropMode ? '' : 'none';
  }});

  // Show/hide preview toggle buttons
  const previewBtns = ['toggle-yellow', 'toggle-red'];
  previewBtns.forEach(id => {{
    document.getElementById(id).style.display = cropMode ? 'none' : '';
  }});

  if (cropMode) {{
    // Switch to raw image (no fade) to see the underlying image clearly
    const img = document.getElementById('main-img');
    img.src = img.dataset.raw;
    fineMode = true;
    document.getElementById('fine-btn').classList.add('active');
    drawBox();
    updateStatus();
  }} else {{
    clearBox();
    pickSrc(document.getElementById('main-img'));
    document.getElementById('status').textContent = '';
  }}
}}

function toggleFine() {{
  fineMode = !fineMode;
  document.getElementById('fine-btn').classList.toggle('active', fineMode);
  updateStatus();
}}

// ── SVG box drawing ───────────────────────────

function drawBox() {{
  const svg = document.getElementById('svg-0');
  const bw = box.right - box.left;
  const bh = box.bottom - box.top;
  const color = '#ff4040';
  const sw = 0.004;
  const hr = 0.011;

  let parts = [];

  // Rectangle
  parts.push(
    '<rect x="' + box.left + '" y="' + box.top + '" ' +
    'width="' + bw + '" height="' + bh + '" ' +
    'fill="none" stroke="' + color + '" stroke-width="' + sw + '" />'
  );

  // 4 edge handles + center move handle
  const handles = [
    {{ s: 'left',   cx: box.left,                    cy: (box.top + box.bottom) / 2, cur: 'ew-resize' }},
    {{ s: 'right',  cx: box.right,                   cy: (box.top + box.bottom) / 2, cur: 'ew-resize' }},
    {{ s: 'top',    cx: (box.left + box.right) / 2,  cy: box.top,                    cur: 'ns-resize' }},
    {{ s: 'bottom', cx: (box.left + box.right) / 2,  cy: box.bottom,                 cur: 'ns-resize' }},
    {{ s: 'move',   cx: (box.left + box.right) / 2,  cy: (box.top + box.bottom) / 2, cur: 'move' }},
  ];

  for (const hl of handles) {{
    const r = (hl.s === 'move') ? hr * 1.3 : hr;
    const fill = (hl.s === lastSide) ? '#ffff00'
               : (hl.s === 'move')   ? '#40a0ff'
               : color;
    parts.push(
      '<circle class="ctrl-point" ' +
      'cx="' + hl.cx + '" cy="' + hl.cy + '" r="' + r + '" ' +
      'fill="' + fill + '" fill-opacity="0.8" stroke="#fff" stroke-width="0.002" ' +
      'data-side="' + hl.s + '" ' +
      'style="cursor:' + hl.cur + '"/>'
    );
  }}

  svg.innerHTML = parts.join('\\n');
}}

function clearBox() {{
  document.getElementById('svg-0').innerHTML = '';
}}

// ── Drag handlers ─────────────────────────────

window.addEventListener('mousedown', (e) => {{
  if (!cropMode) return;
  const t = e.target;
  if (!t.classList || !t.classList.contains('ctrl-point')) return;
  dragSide = t.dataset.side;
  dragTarget = t;
  lastSide = dragSide;
  t.classList.add('dragging');

  const svg = document.getElementById('svg-0');
  const sr = svg.getBoundingClientRect();
  dragStartMouse = {{
    x: (e.clientX - sr.left) / sr.width,
    y: (e.clientY - sr.top)  / sr.height,
  }};
  dragStartBox = JSON.parse(JSON.stringify(box));
  e.preventDefault();
}});

window.addEventListener('mousemove', (e) => {{
  if (!dragSide) return;
  const svg = document.getElementById('svg-0');
  const sr = svg.getBoundingClientRect();
  let mx = (e.clientX - sr.left) / sr.width;
  let my = (e.clientY - sr.top)  / sr.height;

  if (fineMode) {{
    mx = dragStartMouse.x + (mx - dragStartMouse.x) * FINE_SCALE;
    my = dragStartMouse.y + (my - dragStartMouse.y) * FINE_SCALE;
  }}

  const b0 = dragStartBox;
  const MIN = 0.02;

  if (dragSide === 'move') {{
    const dx = mx - dragStartMouse.x;
    const dy = my - dragStartMouse.y;
    const bw = b0.right - b0.left;
    const bh = b0.bottom - b0.top;
    let nl = b0.left + dx;
    let nt = b0.top + dy;
    nl = Math.max(0, Math.min(1 - bw, nl));
    nt = Math.max(0, Math.min(1 - bh, nt));
    box.left = nl; box.right = nl + bw;
    box.top = nt; box.bottom = nt + bh;
  }} else if (dragSide === 'left') {{
    box.left = Math.max(0, Math.min(b0.right - MIN, mx));
  }} else if (dragSide === 'right') {{
    box.right = Math.min(1, Math.max(b0.left + MIN, mx));
  }} else if (dragSide === 'top') {{
    box.top = Math.max(0, Math.min(b0.bottom - MIN, my));
  }} else if (dragSide === 'bottom') {{
    box.bottom = Math.min(1, Math.max(b0.top + MIN, my));
  }}

  drawBox();
  updateStatus();
}});

window.addEventListener('mouseup', () => {{
  if (dragSide) {{
    if (dragTarget) dragTarget.classList.remove('dragging');
    dragSide = null;
    dragTarget = null;
    drawBox();
  }}
}});

// ── Keyboard ──────────────────────────────────

const ARROW_STEP = 0.002;

window.addEventListener('keydown', (e) => {{
  if (!cropMode) return;

  if (e.key === 'f' || e.key === 'F') {{ toggleFine(); return; }}

  if ('12345'.includes(e.key)) {{
    lastSide = ['left', 'right', 'top', 'bottom', 'move'][parseInt(e.key) - 1];
    drawBox();
    updateStatus();
    return;
  }}

  if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) return;
  e.preventDefault();

  const step = fineMode ? ARROW_STEP * FINE_SCALE : ARROW_STEP;

  if (lastSide === 'move') {{
    const bw = box.right - box.left;
    const bh = box.bottom - box.top;
    if (e.key === 'ArrowLeft')  box.left  = Math.max(0, box.left - step);
    if (e.key === 'ArrowRight') box.left  = Math.min(1 - bw, box.left + step);
    if (e.key === 'ArrowUp')    box.top   = Math.max(0, box.top - step);
    if (e.key === 'ArrowDown')  box.top   = Math.min(1 - bh, box.top + step);
    box.right = box.left + bw;
    box.bottom = box.top + bh;
  }} else if (lastSide === 'left') {{
    if (e.key === 'ArrowLeft')  box.left = Math.max(0, box.left - step);
    if (e.key === 'ArrowRight') box.left = Math.min(box.right - 0.02, box.left + step);
  }} else if (lastSide === 'right') {{
    if (e.key === 'ArrowLeft')  box.right = Math.max(box.left + 0.02, box.right - step);
    if (e.key === 'ArrowRight') box.right = Math.min(1, box.right + step);
  }} else if (lastSide === 'top') {{
    if (e.key === 'ArrowUp')   box.top = Math.max(0, box.top - step);
    if (e.key === 'ArrowDown') box.top = Math.min(box.bottom - 0.02, box.top + step);
  }} else if (lastSide === 'bottom') {{
    if (e.key === 'ArrowUp')   box.bottom = Math.max(box.top + 0.02, box.bottom - step);
    if (e.key === 'ArrowDown') box.bottom = Math.min(1, box.bottom + step);
  }}

  drawBox();
  updateStatus();
}});

// ── Status ────────────────────────────────────

function updateStatus() {{
  if (!cropMode) return;
  const fl = fineMode ? '  [FINE]' : '';
  const pxL = Math.round(box.left * ITEM.cropW);
  const pxT = Math.round(box.top * ITEM.cropH);
  const pxR = Math.round(box.right * ITEM.cropW);
  const pxB = Math.round(box.bottom * ITEM.cropH);
  document.getElementById('status').textContent =
    '(' + lastSide + ') ' +
    pxL + ',' + pxT + ' \u2013 ' + pxR + ',' + pxB +
    '  [' + (pxR - pxL) + '\u00d7' + (pxB - pxT) + 'px]' + fl;
}}

function resetBox() {{
  Object.assign(box, JSON.parse(JSON.stringify(initBox)));
  drawBox();
  updateStatus();
}}

// ── PNG metadata injection ────────────────────

// CRC-32 table for PNG chunk checksums
const crcTable = new Uint32Array(256);
for (let n = 0; n < 256; n++) {{
  let c = n;
  for (let k = 0; k < 8; k++) c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
  crcTable[n] = c;
}}
function crc32(buf) {{
  let c = 0xFFFFFFFF;
  for (let i = 0; i < buf.length; i++) c = crcTable[(c ^ buf[i]) & 0xFF] ^ (c >>> 8);
  return (c ^ 0xFFFFFFFF) >>> 0;
}}

function buildChunk(typeStr, dataBytes) {{
  const enc = new TextEncoder();
  const type = enc.encode(typeStr);
  const len = dataBytes.length;
  const chunk = new Uint8Array(12 + len);
  const view = new DataView(chunk.buffer);
  view.setUint32(0, len);
  chunk.set(type, 4);
  chunk.set(dataBytes, 8);
  const crcBuf = new Uint8Array(4 + len);
  crcBuf.set(type, 0);
  crcBuf.set(dataBytes, 4);
  view.setUint32(8 + len, crc32(crcBuf));
  return chunk;
}}

function makeTEXtChunk(keyword, latin1Text) {{
  // tEXt: keyword(Latin-1) + null + text(Latin-1)
  // Caller must ensure text is ASCII/Latin-1 safe
  const kwBytes = new Uint8Array([...keyword].map(c => c.charCodeAt(0)));
  const txtBytes = new Uint8Array([...latin1Text].map(c => c.charCodeAt(0) & 0xFF));
  const data = new Uint8Array(kwBytes.length + 1 + txtBytes.length);
  data.set(kwBytes, 0);
  data[kwBytes.length] = 0;
  data.set(txtBytes, kwBytes.length + 1);
  return buildChunk('tEXt', data);
}}

function makeITXtChunk(keyword, utf8Text) {{
  // iTXt: keyword + null + compression_flag(0) + compression_method(0)
  //       + language_tag + null + translated_keyword + null + text(UTF-8)
  const enc = new TextEncoder();
  const kwBytes = enc.encode(keyword);
  const txtBytes = enc.encode(utf8Text);
  // keyword\0 + 0 + 0 + \0 + \0 + text
  const data = new Uint8Array(kwBytes.length + 1 + 2 + 1 + 1 + txtBytes.length);
  data.set(kwBytes, 0);
  let pos = kwBytes.length;
  data[pos++] = 0;  // null after keyword
  data[pos++] = 0;  // compression flag
  data[pos++] = 0;  // compression method
  data[pos++] = 0;  // null after language tag (empty)
  data[pos++] = 0;  // null after translated keyword (empty)
  data.set(txtBytes, pos);
  return buildChunk('iTXt', data);
}}

function injectPngMetadata(pngArrayBuffer, textMeta, itxtMeta) {{
  // Insert tEXt + iTXt chunks right after the IHDR chunk (first chunk after
  // the 8-byte PNG signature). This avoids the "text after IDAT" warning.
  const src = new Uint8Array(pngArrayBuffer);
  const view = new DataView(pngArrayBuffer);

  // IHDR starts at offset 8; its length is at bytes 8..11
  const ihdrLen = view.getUint32(8);
  // IHDR chunk = 4 (length) + 4 (type) + ihdrLen (data) + 4 (CRC)
  const afterIHDR = 8 + 12 + ihdrLen;

  const chunks = [];
  for (const [key, val] of Object.entries(textMeta)) {{
    chunks.push(makeTEXtChunk(key, val));
  }}
  for (const [key, val] of Object.entries(itxtMeta)) {{
    chunks.push(makeITXtChunk(key, val));
  }}
  const extraLen = chunks.reduce((s, c) => s + c.length, 0);
  const out = new Uint8Array(src.length + extraLen);
  // Copy: signature + IHDR
  out.set(src.subarray(0, afterIHDR), 0);
  // Insert metadata chunks
  let offset = afterIHDR;
  for (const chunk of chunks) {{
    out.set(chunk, offset);
    offset += chunk.length;
  }}
  // Copy remaining chunks (IDAT..IEND)
  out.set(src.subarray(afterIHDR), offset);
  return out.buffer;
}}

// ── Crop export helpers ───────────────────────

function getCroppedBlob() {{
  return new Promise((resolve) => {{
    const rawImg = new Image();
    rawImg.onload = () => {{
      const pxL = Math.round(box.left * rawImg.naturalWidth);
      const pxT = Math.round(box.top * rawImg.naturalHeight);
      const pxR = Math.round(box.right * rawImg.naturalWidth);
      const pxB = Math.round(box.bottom * rawImg.naturalHeight);
      const cw = pxR - pxL;
      const ch = pxB - pxT;
      const canvas = document.createElement('canvas');
      canvas.width = cw;
      canvas.height = ch;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(rawImg, pxL, pxT, cw, ch, 0, 0, cw, ch);
      canvas.toBlob((blob) => resolve({{ blob, cw, ch }}), 'image/png');
    }};
    rawImg.src = document.getElementById('main-img').dataset.raw;
  }});
}}

function getCropMetadata() {{
  const comment = 'Page ' + ITEM.page + ', col ' + ITEM.col +
                  ', line ' + ITEM.lineNum + ', word ' + (ITEM.wordIdx + 1);
  const source = 'Cambridge University Library MS Add. 1753, page ' + ITEM.page;
  // tEXt: Latin-1 safe (no Hebrew, no em dash)
  const textMeta = {{
    'Title': ITEM.book + ' ' + ITEM.cv,
    'Comment': comment,
    'Source': source,
  }};
  // iTXt: full UTF-8 (Hebrew word, em dash)
  const itxtMeta = {{
    'Title': ITEM.book + ' ' + ITEM.cv + ' \u2014 ' + ITEM.word,
    'Comment': comment,
    'Source': source,
  }};
  return {{ textMeta, itxtMeta }};
}}

async function addMetadataToBlob(blob) {{
  const buf = await blob.arrayBuffer();
  const {{ textMeta, itxtMeta }} = getCropMetadata();
  const newBuf = injectPngMetadata(buf, textMeta, itxtMeta);
  return new Blob([newBuf], {{ type: 'image/png' }});
}}

async function copyDataURL() {{
  const {{ blob, cw, ch }} = await getCroppedBlob();
  const metaBlob = await addMetadataToBlob(blob);
  const reader = new FileReader();
  reader.onload = async () => {{
    await navigator.clipboard.writeText(reader.result);
    document.getElementById('status').textContent =
      'Copied data URL to clipboard (' + cw + '\u00d7' + ch + ', with metadata)';
    setTimeout(updateStatus, 2000);
  }};
  reader.readAsDataURL(metaBlob);
}}

async function downloadCrop() {{
  const {{ blob, cw, ch }} = await getCroppedBlob();
  const metaBlob = await addMetadataToBlob(blob);
  const a = document.createElement('a');
  a.download = 'crop_' + ITEM.label + '.png';
  a.href = URL.createObjectURL(metaBlob);
  a.click();
  URL.revokeObjectURL(a.href);
  document.getElementById('status').textContent =
    'Downloaded crop_' + ITEM.label + '.png (' + cw + '\u00d7' + ch + ', with metadata)';
  setTimeout(updateStatus, 2000);
}}
</script>
</body></html>
""")
    print(f"\nHTML: {html_path}")
    url = f"http://127.0.0.1:{SERVER_PORT}/{html_path.name}"
    print(f"Opening {url}")
    webbrowser.open(url)


def main():
    if len(sys.argv) != 4:
        print(
            "Usage: .venv\\Scripts\\python.exe"
            " main_find_word_in_cam1753_images.py <book> <c:v> <hebrew_word>"
        )
        print("Example: ... Job 7:1 \"\u05d5\u05b0\u05db\u05b4\u05d9\u05de\u05b5\u05d9\"")
        sys.exit(1)

    book = sys.argv[1]
    cv = sys.argv[2]
    word = sys.argv[3]
    if ":" not in cv:
        print(f"ERROR: verse must be in c:v format (e.g. 7:1), got: {cv}")
        sys.exit(1)

    result = find_and_preview(word, book, cv)
    if result:
        generate_html(result)
    else:
        sys.exit(1)


if __name__ == "__main__":
    main()
