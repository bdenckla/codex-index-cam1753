# Initially generated by GitHub Copilot.
"""Search for words in Aleppo Codex line-break data."""

import json
from pathlib import Path

from .hebrew_metrics import strip_heb

ROOT = Path(__file__).resolve().parent.parent
LB_DIR = ROOT / "py_ac_loc" / "line-breaks"


def find_word_in_linebreaks(page_id, ch, v, consensus):
    """Find a word in the line-break data.

    Returns (col, line_num, word_index_in_line, line_words)
    where line_words is the list of all words on that line.
    """
    lb_path = LB_DIR / f"{page_id}.json"
    with open(lb_path, encoding="utf-8") as f:
        stream = json.load(f)

    verse_label = f"Job {ch}:{v}"
    in_verse = False
    cur_col = None
    cur_line = None
    word_idx = 0  # 0-based index within current line

    consensus_stripped = strip_heb(consensus)

    # Check if consensus contains maqaf (multi-token in line-break data)
    MAQAF = "\u05BE"
    consensus_has_maqaf = MAQAF in consensus

    # First pass: find which col+line the word is on.
    target_col = None
    target_line = None
    match_count = 0  # count matches to detect ambiguity
    # For maqaf-joined consensus, track the index of the first part
    recent_words = []  # buffer of recent words for maqaf joining
    for item in stream:
        if isinstance(item, dict):
            if item.get("verse-start") == verse_label or item.get("verse-fragment-start") == verse_label:
                in_verse = True
                recent_words = []
                continue
            if item.get("verse-end") == verse_label or item.get("verse-fragment-end") == verse_label:
                in_verse = False
                continue
            if "line-start" in item:
                cur_col = item["line-start"]["col"]
                cur_line = item["line-start"]["line-num"]
                continue
            if "line-end" in item:
                continue
        elif isinstance(item, str) and in_verse:
            item_stripped = strip_heb(item)
            matched = (
                item == consensus
                or item_stripped == consensus_stripped
                or (consensus.endswith(MAQAF) and item_stripped == strip_heb(consensus[:-1]))
            )
            if matched:
                match_count += 1
                if match_count == 1:
                    target_col, target_line = cur_col, cur_line
                continue

            # Try joining recent maqaf-ending words with the current word
            if consensus_has_maqaf:
                recent_words.append(item)
                # Keep only words that could form the start of the consensus
                joined = "".join(recent_words)
                joined_stripped = strip_heb(joined)
                if joined_stripped == consensus_stripped or joined == consensus:
                    match_count += 1
                    if match_count == 1:
                        target_col, target_line = cur_col, cur_line
                    continue
                # If joined doesn't start the consensus, trim from the left
                while recent_words and not consensus_stripped.startswith(strip_heb("".join(recent_words))):
                    recent_words.pop(0)

    if match_count > 1:
        raise ValueError(
            f"Ambiguous: {match_count} matches for {consensus!r} "
            f"(stripped: {consensus_stripped!r}) in {verse_label} on page {page_id}"
        )

    if target_col is None:
        return None, None, None, []

    # Second pass: collect all words on that line
    in_target_line = False
    cur_line_words = []
    for item in stream:
        if isinstance(item, dict):
            if "line-start" in item:
                ls = item["line-start"]
                if ls["col"] == target_col and ls["line-num"] == target_line:
                    in_target_line = True
                    cur_line_words = []
                continue
            if "line-end" in item and in_target_line:
                break
        elif isinstance(item, str) and in_target_line:
            cur_line_words.append(item)

    # Find word index within the full line word list
    target_word_idx = None
    for i, w in enumerate(cur_line_words):
        w_stripped = strip_heb(w)
        if (w == consensus
                or w_stripped == consensus_stripped
                or (consensus.endswith(MAQAF) and w_stripped == strip_heb(consensus[:-1]))):
            target_word_idx = i
            break
        # Try joining consecutive maqaf-connected words starting at i
        if consensus_has_maqaf and w.endswith(MAQAF):
            joined = w
            for j in range(i + 1, len(cur_line_words)):
                joined += cur_line_words[j]
                j_stripped = strip_heb(joined)
                if j_stripped == consensus_stripped or joined == consensus:
                    target_word_idx = i
                    break
                if not cur_line_words[j].endswith(MAQAF):
                    break
            if target_word_idx is not None:
                break

    return target_col, target_line, target_word_idx, cur_line_words
