# Initially generated by GitHub Copilot.
"""Verify that the cam1753 word-finding code finds every quirkrec word,
and that the found location matches the expected cam1753-loc.

Test data in test-data-from-book-of-job.json is a minimal extract of
the book-of-job repo's enriched-quirkrecs.json, containing only the
fields needed for this test.
"""

import json
import sys
from pathlib import Path

from py_cam1753_word_image.linebreak_search import find_word_in_linebreaks
from py_cam1753_word_image.page import LB_DIR, find_pages_for_verse

ROOT = Path(__file__).resolve().parent
TEST_DATA = ROOT / "test-data-from-book-of-job.json"


def main():
    data = json.loads(TEST_DATA.read_text("utf-8"))

    pass_count = 0
    fail_count = 0
    failures = []
    method_counts = {}  # match_method -> count
    stripped_records = []  # (cv, consensus) for non-exact matches

    for rec in data:
        cv = rec["qr-cv"]
        consensus = rec["qr-consensus"]
        lb_word = rec.get("qr-consensus-ketiv", consensus)
        loc = rec["qr-cam1753-loc"]

        ch_str, v_str = cv.split(":")
        ch, v = int(ch_str), int(v_str)

        expected_page = loc["page"]
        expected_col = loc["column"]
        expected_line = loc["line"]
        expected_word = loc["word"]  # 1-based

        # Find pages for this verse
        pages = find_pages_for_verse("Job", ch, v)
        if not pages:
            msg = f"FAIL {cv} {consensus!r}: no pages found for verse"
            print(msg)
            failures.append(msg)
            fail_count += 1
            continue

        # Try finding the word on the expected page first, then all pages
        try:
            col, line_num, word_idx, line_words, match_method = find_word_in_linebreaks(
                LB_DIR, expected_page, "Job", ch, v, lb_word
            )
        except ValueError as e:
            # Ambiguous match - try multi-page
            try:
                col, line_num, word_idx, line_words, match_method = (
                    find_word_in_linebreaks(LB_DIR, pages, "Job", ch, v, lb_word)
                )
            except ValueError as e2:
                msg = f"FAIL {cv} {consensus!r}: {e2}"
                print(msg)
                failures.append(msg)
                fail_count += 1
                continue

        if col is None:
            # Also try all pages
            try:
                col, line_num, word_idx, line_words, match_method = (
                    find_word_in_linebreaks(LB_DIR, pages, "Job", ch, v, lb_word)
                )
            except ValueError as e:
                msg = f"FAIL {cv} {consensus!r}: {e}"
                print(msg)
                failures.append(msg)
                fail_count += 1
                continue

        if col is None:
            msg = (
                f"FAIL {cv} {consensus!r}: word not found in linebreaks"
                f" (pages={pages})"
            )
            print(msg)
            failures.append(msg)
            fail_count += 1
            continue

        # The finder returns 0-based word_idx; cam1753-loc uses 1-based
        found_word_1based = word_idx + 1 if word_idx is not None else None

        # For maqaf words that span lines, some locs have "line2"/"word2"
        has_line2 = "line2" in loc

        # Compare
        mismatches = []
        if col != expected_col:
            mismatches.append(f"col: found={col} expected={expected_col}")
        if line_num != expected_line:
            if has_line2 and line_num == loc.get("line2"):
                pass  # acceptable: found on line2
            else:
                mismatches.append(f"line: found={line_num} expected={expected_line}")
        if found_word_1based != expected_word:
            if has_line2 and found_word_1based == loc.get("word2"):
                pass  # acceptable: found as word2
            else:
                mismatches.append(
                    f"word: found={found_word_1based} expected={expected_word}"
                )

        if mismatches:
            mismatch_str = "; ".join(mismatches)
            msg = (
                f"MISMATCH {cv} {consensus!r}: {mismatch_str}"
                f"  (line_words={line_words})"
            )
            print(msg)
            failures.append(msg)
            fail_count += 1
        else:
            pass_count += 1
            method_counts[match_method] = method_counts.get(match_method, 0) + 1
            if match_method != "exact":
                stripped_records.append((cv, consensus, match_method))

    print(f"\n{'=' * 60}")
    print(f"PASS: {pass_count}")
    print(f"FAIL: {fail_count}")
    print(f"TOTAL: {pass_count + fail_count}")
    if method_counts:
        print(f"\nMatch methods (passing records):")
        for method, count in sorted(method_counts.items()):
            print(f"  {method}: {count}")
    if stripped_records:
        print(
            f"\nRecords requiring non-exact (stripped) match ({len(stripped_records)}):"
        )
        for cv, word, method in stripped_records:
            print(f"  {cv} {word!r}  [{method}]")
    if failures:
        print(f"\nFailures:")
        for f in failures:
            print(f"  {f}")
        return 1
    print("\nAll quirkrecs PASS!")
    return 0


if __name__ == "__main__":
    sys.exit(main())
